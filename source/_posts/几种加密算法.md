---
layout: w
title: 几种加密算法
date: 2019-08-02 15:42:20
tags: 逆向工程
---

### <center>浅谈几种加密算法之Hash算法</center>

---

#### 单向散列算法（Hash算法）

   简介：常见的Hash算法包括*MD5，SHA， RIPE-MD ，HAVAL*等

对于解密而言，只要能识别出是何种算法，就可以直接套用相关算法的源码解决。

##### 1.MD5算法： 

######  算法原理：

 1. 数据填充：附加一个1在消息后面，然后用0来填充，直到消息长度与448模512同余（长度=448模512），即**填充后的消息长度比512的倍数小64位**

 2. 添加长度：如果填充前消息的长度大于2的64次方 , 则只使用其低 64位。添加填充位和消息长度之后，最终消息的长度正好是 512 的整数倍。令 M[O···N-I] 表示最终的消息，其中 N是 16 的倍数。

 3. 初始化变量：用4个变量(A、B、C、D)来计算消息摘要。这里的A、B、 C、D都是32位的寄存器。这些寄存器以下面的十六进制数来初始化：
    A = 01234567h, B = 89abcdefh, C = fedcba98h, D = 7654321 Oh 而且，在内存中是以低字节在前的形式存储的， 即如下格式：

    ```
    01 23 45 67 89 AB CD EF FE DC BA 98 76 54 32 10	
    ```

4. 数据处理：所用的加法常数由表T[i]来定义， 其中 l为1至64之中的值。T[i]等于4294967296乘以abs(sin(i))所得结果的整数部分， 其中l用弧度来表示。这样做是为了通过正弦函数和幕函数来进一 步消除变换中的线性。

   算法具体实现较为复杂。

   ```
   A=A+AA
   B=B+BB 
   C=C+CC 
   D=D+CC
   ```

5. 输出：当512位分组都运算完毕， A、 B、 C、 D的级联将被输出为MD5散列的结果。

###### 算法应用：

​	看一看如下使用MD5判断注册码的伪码：

```
		if ( MD5(用户名) ＝＝ 序列号 )

​				正确的注册码；

​		else

​				错误的注册码
```

从上面看出了什么？

**序列号就以明文的形式存在内存中！！！**

MD5代码的特点非常明显， 跟踪时很容易发现。 如果软件采用MD5算法， 在初始化数据时必然会用到上面提到的4个常数(A、 B 、 C、 D)。 实际上， 像KANAL这样的算法分析工具不是通过这4个常数来鉴别MD5的，而是通过识别具有64个常骰元素的表T来判断是不是MD5算法的。对于变形的MD5算法，常见的情况有3种： **一是改变初始化时用到的4个常数；二是改变填充的方法； 三是改变Hash变换的处理过程**。 在解密时， 只要跟踪以上这些点， 对MD5的源代码进行修改， 就可以实现相应的注册机制了

##### 实例：

用OD打开一个例子：

```
0040118B  |.  FFD5          call    ebp                              ; \GetDlgItemTextA
0040118D  |.  83F8 13       cmp     eax, 13                          ;  密码长度0x13位
00401190  |.  0F85 F3000000 jnz     00401289
00401196  |.  8A4C24 64     mov     cl, byte ptr [esp+64]            ;  注册码第五位是-吗
0040119A  |.  B0 2D         mov     al, 2D
0040119C  |.  3AC8          cmp     cl, al
0040119E  |.  0F85 E5000000 jnz     00401289
004011A4  |.  384424 69     cmp     byte ptr [esp+69], al            ;  注册码第十位是-吗
004011A8  |.  0F85 DB000000 jnz     00401289
004011AE  |.  384424 6E     cmp     byte ptr [esp+6E], al            ;  注册码第十五位是-吗
004011B2  |.  0F85 D1000000 jnz     00401289
004011B8  |.  8B4C24 65     mov     ecx, dword ptr [esp+65]
004011BC  |.  8B4424 60     mov     eax, dword ptr [esp+60]
004011C0  |.  8B5424 6A     mov     edx, dword ptr [esp+6A]
004011C4  |.  894C24 14     mov     dword ptr [esp+14], ecx
004011C8  |.  894424 10     mov     dword ptr [esp+10], eax
004011CC  |.  8B4424 6F     mov     eax, dword ptr [esp+6F]
004011D0  |.  8D8C24 280100>lea     ecx, dword ptr [esp+128]
004011D7  |.  895424 18     mov     dword ptr [esp+18], edx
004011DB  |.  51            push    ecx                              ;  MD5 Content
004011DC  |.  894424 20     mov     dword ptr [esp+20], eax
004011E0  |.  E8 CB000000   call    004012B0
```

此处跟进004012B0,进行MD5的初始化;

```
004012B0  /$  8B4424 04     mov     eax, dword ptr [esp+4]
004012B4  |.  33C9          xor     ecx, ecx
004012B6  |.  8948 14       mov     dword ptr [eax+14], ecx
004012B9  |.  8948 10       mov     dword ptr [eax+10], ecx
004012BC  |.  C700 01234567 mov     dword ptr [eax], 67452301
004012C2  |.  C740 04 89ABC>mov     dword ptr [eax+4], EFCDAB89
004012C9  |.  C740 08 FEDCB>mov     dword ptr [eax+8], 98BADCFE
004012D0  |.  C740 0C 76543>mov     dword ptr [eax+C], 10325476
004012D7  \.  C3            retn
```

保存散列值的缓冲区地址；

```
0040122A  |.  51            push    ecx
0040122B  |.  52            push    edx
0040122C  |.  E8 5F010000   call    00401390
```

经过call调用，保存在edx中；

计算MD5值

```
00401231  |.  83C4 14       add     esp, 14
00401234  |.  33C0          xor     eax, eax
00401236  |>  8A8C04 800100>/mov     cl, byte ptr [esp+eax+180]
0040123D  |.  83E1 1F       |and     ecx, 1F
00401240  |.  40            |inc     eax
00401241  |.  83F8 10       |cmp     eax, 10
00401244  |.  8A540C 3C     |mov     dl, byte ptr [esp+ecx+3C]
00401248  |.  889404 0F0300>|mov     byte ptr [esp+eax+30F], dl
0040124F  |.^ 7C E5         \jl      short 00401236
00401251  |.  8D8424 100300>lea     eax, dword ptr [esp+310]
00401258  |.  8D4C24 10     lea     ecx, dword ptr [esp+10]
0040125C  |.  50            push    eax                              ; /String2
0040125D  |.  51            push    ecx                              ; |String1
0040125E  |.  FF15 00604000 call    dword ptr [<&KERNEL32.lstrcmpA>] ; \lstrcmpA
00401264  |.  85C0          test    eax, eax
00401266  |.  75 21         jnz     short 00401289


```

