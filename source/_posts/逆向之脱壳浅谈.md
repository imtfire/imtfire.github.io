---
title: 逆向之脱壳浅谈
date: 2019-08-09 17:53:59
tags: 逆向工程
---

### <center>关于脱壳技术</center>

*有加壳就一定有脱壳*

---

#### 1. 壳的基础知识

1. 壳的加载过程：与病毒类似，比源程序更早的获得控制权。
   1. 在初始化时保存个寄存器的值，等到外壳执行完成再恢复各寄存器的内容，最后跳转到源程序运行。
   
   2. 获取壳本身需要用到的API地址，一般只使用GetProcAddress，GetModuleHandle和LoadLibrary三个API函数，如果需要其他的用LoadLibrary加载。
   
   3.  按区块解密，把解密的区块数据按照区块的定义放在内存中合适的位置。
   
   4.  IAT的初始化
   
   5.   重定位项的处理，文件执行时将被映射到指定内存地址中，这个初始内存地址称为基址。对EXE的程序文件来说，Windows操作系统会尽量满足其要求。例如，某EXE文件的基地址为400000h, 而运行时 Windows操作系统提供给程序的基地址也是400000h, 在这种情况下就不需要进行地址 ”重定位” 了。由于不需要对EXE文件进行 ”重定位”，加壳软件干脆删除了原程序文件中用千保存重定位信息的区块（这样做可以使加壳后的文件更加小巧，有些工具提供的 "Wipe Reloc"功能其实就起到了这个作用）。
   
   6.  Hook API。在程序文件中，输入表的作用是让Windows操作系统在程序运行时将API的实际地址提供给程序使用。在程序的第1行代码被执行之前，Windows操作系统就完成了这项工作。
      壳大都在修改原程序文件的输入表后自己模仿Windows操作系统的工作流程，向输入表中填充相关的数据。在填充过程中，外壳可以填充 HookAPI 代码的地址，从而间接获得程序的控制权。
   
   7.   跳转到程序原入口点(OEP)，从这个时候起，壳就把控制权还给原程序了。越来越多的加密壳先将 OEP 代码段搬到外壳的地址空间里，再将这段代码清除（这种技术称为 "Stolen Bytes")。这样，OEP与外壳之间那条明显的 “分界线” 就消失了，脱壳的难度也就增加了。
   
2. 脱壳(主要是手动脱壳)
   1. *查找真正的程序入口点*
   2. *抓取内存映像文件*
   3. *重建PE文件*
程序 执行时，外壳代码首先获得控制权，模拟windows加载器，将原来的程序回复到内存中，此时内存中的数据就是加壳前的映像文件。适时将其抓取并修改，即可还原到加壳前的状态。

---

#### 2. 脱壳

1. ###### 寻找OEP

   *当外壳所保护的程序运行时，会先执行外壳程序，外壳程序负责将在内存中把源程序解压还原，并将控制权还给解压后的真正程序，再跳转到原来的程序入口点。这个入口点称为“OEP”*

   1. 根据跨段指令寻找OEP：
      当外壳代码处理完毕会跳转带程序本身的代码处；所以根据跨段的转移指令就能找到真正的程序入口点。
   
   2. 根据内存访问断点寻找OEP：待代码段解压完毕对代码段设置内存访问断点。如果之前设置了断点，程序会不停的对代码进行写入的指令处中断。解决方法：即设置两次内存断点。因为一般的壳会依次对.text、 .rdata 、 .data 、 .rsrc区块进行解压处理，所以，可以先在.rdata 、 .data 等 区块处设置内存访问断点，待程序中断， 代码段已解压，再对代码段(.text块）设置内存访问断点，到达OEP。
   
   3. 根据栈平衡原理寻找OEP：在编写加壳软件时，必须保证外壳初始化的现场环境（各寄存器值）与原程序的现场环境是相同的（主要是esp、 ebp等重要的寄存器值）。加壳程序在初始化时保存各寄存器的值，待外壳执行完毕恢复 各寄存器的内容， 最后跳转到原程序执行。通常用pushad/popad、pushfd/popfd指令对来保存与恢复现场环境 。其中，eflags (标志寄存器 ）不是太重要， 一般不 处理它。也就是说，在编写加 壳软件时，必须遵守栈平衡原理。
   
      |   PUSHAD   | 相当于push eax/ecx/edx等 |
      | :--------: | ------------------------ |
      |    ...     | 外壳代码                 |
      |   POPAD    | 相当于pop eax/ecx/edx等  |
      |  JMP OEP   | 准备跳到入口点           |
      | OEP:   ... | 解压后程序的源代码       |
   
      

2. ###### 抓取内存映像

   抓取内存映像， 也称 “转存" (Dump), 是指把内存指定地址的映像文件 读出，用文件等形式将其保存下来的过程。
   脱壳时，在何时Dump 文件是有一定技巧的。在一般情况下，当外壳来到 OEP 处时进行Dump 是正确的。如果等到程序运行起来， 由于一些变量已经初始化了， 不适合进行 Dump。在外壳处理过程中， 外壳要把压缩后的全部代码数据释放到内存中， 并初始化一些项目。

   **Dump原理：**
   常用的Dump软件 有LordPE、PETools等。这类工具一般利用 Module32Next来获取欲Dump 进 程的 基本信息。Module32Next 函数的原型如下：

   ```c
   BOOL Module32Next(
   HANDLE hSnapshot ,
   LPMODULEENTRY32 lpme
   )
   ```

   •	hSnapshot : 由先前的CreateToolhelp32Snapshot 函数返回的快照。
   •	lpme: 指向MODULEENTRY32结构的指针。

   *每次执行函数后，都会把一个进程的信息填入MODULEENTRY32结构。*

   ```c
   typedef struct tagMODULEENTRY32 {
   DWORD dwSize;
   DWORD th32ModuleID;
   DWORD th32ProcessID;
   DWORD GlblcntUsage;
   DWORD ProccntUsage;
   BYTE *modBaseAddr;
   DWORD modBaseSize;
   HMODULE hModule;
   TCHAR szModule[MAX_PATH];
   TCHAR szExePath[MAX_PATH];
   } MODULEENTRY32, *PMODULEENTRY32, *LPMODULEENTRY32;
   ```

   LordPE和ProcDump都是先根据此结构中的 modBaseSize和modBaseAddr 字段得到进程的映像 大小和基址，再调用 ReadProcessMemory来读取进程内的数据的。如果读取成功，ProcDump会检测 IMAGE_DOS_SIGN ATURE和IMAGE_NT_SIGNATURE 是否完整。如果完整，就基本上不会对剩余的大多数字段进行检验了；如果不 完整， 会根据 szExePath字段打开进程的原始文件 ，读取其文件头以取代进程的文件头。LordPE则更简单，根本不使用进程的文件头，而直接读取原始文件 的文件头， 在读取内存数据后，再把进程中的数据保存到磁盘文件 中。

   

3. ###### 重建PE文件

   破坏原程序的输入表是加密外壳必须具备的功能。在脱壳中，输入表处理是此要求脱壳者对PE格式中的输入表概念非常清楚。

   1. 输入表重建的原理：在输入表结构中，与实际运行相关的主要是IAT结构，这个结构用于保存 API的实际地址。PE文件运行时将初始化输入表的这一部分，Wind ows加载器首先搜索 OriginalFirstThunk, 如果存在，加载程序将迭代搜索数组中的每个指针，找到每个IMAGE_IMPORT_BY_NA ME 结构所指向的输入函数的地址，然后，加载器用函数真正的入口地址代替由FirstThunk指向的IMAGE_THUNK_DATA 数组里元素的值。 此时，输入表中的其他部分就不重要了，程序依靠IAT提供的函数地址就可以正常运行。外壳程序一般都会修改原程序文件的输入，然后自己模仿PE装载器来填充IAT的相关数据，也就是说，内存中只有一个IAT, 原程序的输入表不在内存中。输入表重建就是根据这个IAT还原整个输入表的结构（即如图16.17所示的这个结构），包括IID结构及其各成员指向的数据等。一些加密软件为 了防止输入表被还原， 就在IAT加密上大作文章。此时， 由外壳填充到IAT里 的不是实际的 API 地址，而是用于Hook API的外壳 代码的地址 。这样， 外壳中的代码一旦完成了加 载工作，在进入原程序的代码之后，仍然能够间接 获得程序的控制权。因为程序总要与系统打交道，与系统打交道的途径是 API, 而API的地址已经被替换成了外壳的Hook API的地址，所以， 每次程序与系统打交道，都会让外壳的代码获得一次 控制权。这样， 外壳 就可以 进行反跟踪， 从而继续保护软件， 同时完成某些特殊的任务了 。综上所述， **重建输入表的关键是获取未加密的IAT。 一般的 做法是跟踪加壳程序对IAT的处理过程， 修改相关指令， 不让外壳加密 IAT。**
   2.  确定IAT的地址与大小：一般程序的IAT是连续排列的， 以一个DWORD字的O作为结束， 因此， 只要确定IAT的一个点， 就能获得整个IAT的地址和大小。
   3. 根据IAT重建输入表：数据处理完成后，UPX外壳使用了一次跨段的转移指令勺mp)跳转到OEP,发现OEP的地址为401000h,因此只需要在4052BFh处设置断点。程序中断后，运行LordPE,将内存数据Dump出来并保存为dumped.exe。用十六进制工具在dumped.exe文件中找一块空间，在这里选择2100h,将表16.1中的DLL名和
      函数名写进去，如图16.27所示。DLL名与函数名的位置可以任意指定。在每个函数名前面要留2 字节来存放函数的序号，序号可以为O;每个函数名后的1字节为O;每个函数名或DLL名的起始地址必须按偶数对齐， 空隙用0填充。由千是内存映像文件，文件 偏移地址与相对虚拟地址(RVA)的值是相等的，IAT 的位置很重要，不能改变，否则相关指令就找不到函数调用地址了（除非再修正这些函数调用的地址）。IAT 中的内容可以不重新构造，当加载PE文件时，Windows操作系统会对其进行填充。


