<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Enthusiasm And Focus</title>
  
  <subtitle>Always Maintain a Santa Claus</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-08-02T10:43:25.658Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>tfire</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>几种加密算法</title>
    <link href="http://yoursite.com/2019/08/02/%E5%87%A0%E7%A7%8D%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/08/02/几种加密算法/</id>
    <published>2019-08-02T07:42:20.000Z</published>
    <updated>2019-08-02T10:43:25.658Z</updated>
    
    <content type="html"><![CDATA[<h3 id="浅谈几种加密算法之Hash算法"><a href="#浅谈几种加密算法之Hash算法" class="headerlink" title="浅谈几种加密算法之Hash算法"></a><center>浅谈几种加密算法之Hash算法</center></h3><hr><h4 id="单向散列算法（Hash算法）"><a href="#单向散列算法（Hash算法）" class="headerlink" title="单向散列算法（Hash算法）"></a>单向散列算法（Hash算法）</h4><p>   简介：常见的Hash算法包括<em>MD5，SHA， RIPE-MD ，HAVAL</em>等</p><p>对于解密而言，只要能识别出是何种算法，就可以直接套用相关算法的源码解决。</p><h5 id="1-MD5算法："><a href="#1-MD5算法：" class="headerlink" title="1.MD5算法："></a>1.MD5算法：</h5><h6 id="算法原理："><a href="#算法原理：" class="headerlink" title="算法原理："></a>算法原理：</h6><ol><li><p>数据填充：附加一个1在消息后面，然后用0来填充，直到消息长度与448模512同余（长度=448模512），即<strong>填充后的消息长度比512的倍数小64位</strong></p></li><li><p>添加长度：如果填充前消息的长度大于2的64次方 , 则只使用其低 64位。添加填充位和消息长度之后，最终消息的长度正好是 512 的整数倍。令 M[O···N-I] 表示最终的消息，其中 N是 16 的倍数。</p></li><li><p>初始化变量：用4个变量(A、B、C、D)来计算消息摘要。这里的A、B、 C、D都是32位的寄存器。这些寄存器以下面的十六进制数来初始化：<br>A = 01234567h, B = 89abcdefh, C = fedcba98h, D = 7654321 Oh 而且，在内存中是以低字节在前的形式存储的， 即如下格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">01 23 45 67 89 AB CD EF FE DC BA 98 76 54 32 10</span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li><p>数据处理：所用的加法常数由表T[i]来定义， 其中 l为1至64之中的值。T[i]等于4294967296乘以abs(sin(i))所得结果的整数部分， 其中l用弧度来表示。这样做是为了通过正弦函数和幕函数来进一 步消除变换中的线性。</p><p>算法具体实现较为复杂。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A=A+AA</span><br><span class="line">B=B+BB </span><br><span class="line">C=C+CC </span><br><span class="line">D=D+CC</span><br></pre></td></tr></table></figure></li><li><p>输出：当512位分组都运算完毕， A、 B、 C、 D的级联将被输出为MD5散列的结果。</p></li></ol><h6 id="算法应用："><a href="#算法应用：" class="headerlink" title="算法应用："></a>算法应用：</h6><p>​    看一看如下使用MD5判断注册码的伪码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if ( MD5(用户名) ＝＝ 序列号 )</span><br><span class="line"></span><br><span class="line">​正确的注册码；</span><br><span class="line"></span><br><span class="line">​else</span><br><span class="line"></span><br><span class="line">​错误的注册码</span><br></pre></td></tr></table></figure><p>从上面看出了什么？</p><p><strong>序列号就以明文的形式存在内存中！！！</strong></p><p>MD5代码的特点非常明显， 跟踪时很容易发现。 如果软件采用MD5算法， 在初始化数据时必然会用到上面提到的4个常数(A、 B 、 C、 D)。 实际上， 像KANAL这样的算法分析工具不是通过这4个常数来鉴别MD5的，而是通过识别具有64个常骰元素的表T来判断是不是MD5算法的。对于变形的MD5算法，常见的情况有3种： <strong>一是改变初始化时用到的4个常数；二是改变填充的方法； 三是改变Hash变换的处理过程</strong>。 在解密时， 只要跟踪以上这些点， 对MD5的源代码进行修改， 就可以实现相应的注册机制了</p><h5 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h5><p>用OD打开一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">0040118B  |.  FFD5          call    ebp                              ; \GetDlgItemTextA</span><br><span class="line">0040118D  |.  83F8 13       cmp     eax, 13                          ;  密码长度0x13位</span><br><span class="line">00401190  |.  0F85 F3000000 jnz     00401289</span><br><span class="line">00401196  |.  8A4C24 64     mov     cl, byte ptr [esp+64]            ;  注册码第五位是-吗</span><br><span class="line">0040119A  |.  B0 2D         mov     al, 2D</span><br><span class="line">0040119C  |.  3AC8          cmp     cl, al</span><br><span class="line">0040119E  |.  0F85 E5000000 jnz     00401289</span><br><span class="line">004011A4  |.  384424 69     cmp     byte ptr [esp+69], al            ;  注册码第十位是-吗</span><br><span class="line">004011A8  |.  0F85 DB000000 jnz     00401289</span><br><span class="line">004011AE  |.  384424 6E     cmp     byte ptr [esp+6E], al            ;  注册码第十五位是-吗</span><br><span class="line">004011B2  |.  0F85 D1000000 jnz     00401289</span><br><span class="line">004011B8  |.  8B4C24 65     mov     ecx, dword ptr [esp+65]</span><br><span class="line">004011BC  |.  8B4424 60     mov     eax, dword ptr [esp+60]</span><br><span class="line">004011C0  |.  8B5424 6A     mov     edx, dword ptr [esp+6A]</span><br><span class="line">004011C4  |.  894C24 14     mov     dword ptr [esp+14], ecx</span><br><span class="line">004011C8  |.  894424 10     mov     dword ptr [esp+10], eax</span><br><span class="line">004011CC  |.  8B4424 6F     mov     eax, dword ptr [esp+6F]</span><br><span class="line">004011D0  |.  8D8C24 280100&gt;lea     ecx, dword ptr [esp+128]</span><br><span class="line">004011D7  |.  895424 18     mov     dword ptr [esp+18], edx</span><br><span class="line">004011DB  |.  51            push    ecx                              ;  MD5 Content</span><br><span class="line">004011DC  |.  894424 20     mov     dword ptr [esp+20], eax</span><br><span class="line">004011E0  |.  E8 CB000000   call    004012B0</span><br></pre></td></tr></table></figure><p>此处跟进004012B0,进行MD5的初始化;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">004012B0  /$  8B4424 04     mov     eax, dword ptr [esp+4]</span><br><span class="line">004012B4  |.  33C9          xor     ecx, ecx</span><br><span class="line">004012B6  |.  8948 14       mov     dword ptr [eax+14], ecx</span><br><span class="line">004012B9  |.  8948 10       mov     dword ptr [eax+10], ecx</span><br><span class="line">004012BC  |.  C700 01234567 mov     dword ptr [eax], 67452301</span><br><span class="line">004012C2  |.  C740 04 89ABC&gt;mov     dword ptr [eax+4], EFCDAB89</span><br><span class="line">004012C9  |.  C740 08 FEDCB&gt;mov     dword ptr [eax+8], 98BADCFE</span><br><span class="line">004012D0  |.  C740 0C 76543&gt;mov     dword ptr [eax+C], 10325476</span><br><span class="line">004012D7  \.  C3            retn</span><br></pre></td></tr></table></figure><p>保存散列值的缓冲区地址；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0040122A  |.  51            push    ecx</span><br><span class="line">0040122B  |.  52            push    edx</span><br><span class="line">0040122C  |.  E8 5F010000   call    00401390</span><br></pre></td></tr></table></figure><p>经过call调用，保存在edx中；</p><p>计算MD5值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">00401231  |.  83C4 14       add     esp, 14</span><br><span class="line">00401234  |.  33C0          xor     eax, eax</span><br><span class="line">00401236  |&gt;  8A8C04 800100&gt;/mov     cl, byte ptr [esp+eax+180]</span><br><span class="line">0040123D  |.  83E1 1F       |and     ecx, 1F</span><br><span class="line">00401240  |.  40            |inc     eax</span><br><span class="line">00401241  |.  83F8 10       |cmp     eax, 10</span><br><span class="line">00401244  |.  8A540C 3C     |mov     dl, byte ptr [esp+ecx+3C]</span><br><span class="line">00401248  |.  889404 0F0300&gt;|mov     byte ptr [esp+eax+30F], dl</span><br><span class="line">0040124F  |.^ 7C E5         \jl      short 00401236</span><br><span class="line">00401251  |.  8D8424 100300&gt;lea     eax, dword ptr [esp+310]</span><br><span class="line">00401258  |.  8D4C24 10     lea     ecx, dword ptr [esp+10]</span><br><span class="line">0040125C  |.  50            push    eax                              ; /String2</span><br><span class="line">0040125D  |.  51            push    ecx                              ; |String1</span><br><span class="line">0040125E  |.  FF15 00604000 call    dword ptr [&lt;&amp;KERNEL32.lstrcmpA&gt;] ; \lstrcmpA</span><br><span class="line">00401264  |.  85C0          test    eax, eax</span><br><span class="line">00401266  |.  75 21         jnz     short 00401289</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;浅谈几种加密算法之Hash算法&quot;&gt;&lt;a href=&quot;#浅谈几种加密算法之Hash算法&quot; class=&quot;headerlink&quot; title=&quot;浅谈几种加密算法之Hash算法&quot;&gt;&lt;/a&gt;&lt;center&gt;浅谈几种加密算法之Hash算法&lt;/center&gt;&lt;/h3&gt;&lt;hr&gt;
      
    
    </summary>
    
    
      <category term="逆向工程" scheme="http://yoursite.com/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>经典栈溢出问题</title>
    <link href="http://yoursite.com/2019/07/30/%E7%BB%8F%E5%85%B8%E6%A0%88%E6%BA%A2%E5%87%BA%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/07/30/经典栈溢出问题/</id>
    <published>2019-07-30T13:10:54.000Z</published>
    <updated>2019-07-30T16:39:43.874Z</updated>
    
    <content type="html"><![CDATA[<h3 id="经典栈溢出问题"><a href="#经典栈溢出问题" class="headerlink" title="经典栈溢出问题"></a><center>经典栈溢出问题</center></h3><hr><p>​    说到二进制安全，肯定避不开栈溢出，今天就拿栈溢出作为开始，讨论一下它的形成与构造。</p><h4 id="1-程序的内存空间"><a href="#1-程序的内存空间" class="headerlink" title="1. 程序的内存空间"></a>1. 程序的内存空间</h4><p>​    首先，先介绍一下应用程序内存空间布局，用一张图来说明，简单粗暴。</p><p><img src="/2019/07/30/经典栈溢出问题/3.1.png" alt></p><p>简单介绍一下就是，每个应用程序都有4个GB的虚拟空间（在windows编程的虚拟内存中介绍了），高1个GB作为内核空间，用户代码无权访问，所有的应用程序共享这部分空间。而低3个GB的空间是用户代码，有stack ，heap ，MMap（存放动态链接库）等等，本文重点介绍stack。</p><p>有关堆，栈在虚拟空间中的概念：</p><p>1.栈自底向上增长，尺寸动态变化，默认临界大小是8M。</p><p>2.Stack和mmap间有个随机偏移量用于防止栈溢出污染mmap。</p><p>3.Mappings区间主要布置动态链接库。</p><p>4.默认进程堆自顶向下增长。</p><hr><h4 id="2-栈帧"><a href="#2-栈帧" class="headerlink" title="2. 栈帧"></a>2. 栈帧</h4><ul><li>栈是一种LIFO的数据结构。</li><li>应用程序有一到多个用户态栈。</li><li>栈自底向上增长，由指令PUSH和POP引起其动态变化。</li><li>局部变量布局在栈中。</li><li>调用函数时参数由栈传递，返回地址也存储于栈中。</li><li>函数调用上下文与局部变量共同组成了栈帧——Stack Frame.</li></ul><p>总结一下：栈帧=局部变量+函数调用上下文</p><p>再简单点的说：栈帧实际上只是一个通俗的说法，关于栈帧的上下界历来有两种说法，一曰以EBP和ESP之间的栈空间视为栈帧，这也是主流说法；一曰以调用参数和ESP之间的栈空间视为栈帧，我个人更倾向于这种说法，因为它便于理解。</p><hr><h4 id="3-经典栈溢出的手法"><a href="#3-经典栈溢出的手法" class="headerlink" title="3. 经典栈溢出的手法"></a>3. 经典栈溢出的手法</h4><p>经典栈溢出的手法概要：</p><ul><li><p>先决条件：栈局部变量可控，存在溢出(strcpy)。</p></li><li><p>通过栈空间精心布局，布置shellcode，并用shellcode起始地址覆盖栈帧的ret addr。</p></li></ul><p>存在的问题：</p><ul><li>Shellcode地址在不同PC上不确定</li><li>每次运行地址都会变化（ASLR）</li></ul><p>拿一个例子说明：</p><p><img src="/2019/07/30/经典栈溢出问题/3.2.png" alt></p><p>出现的问题：</p><ol><li>fread时，指定的长度1024超过了buf尺寸。</li><li>输入数据长度可控，在input.txt中。</li><li>可以精心操纵input.txt，对buf进行溢出布置shellcode、覆盖ret addr。</li><li>当返回的地址可以被控制时，问题就大发了。</li></ol><p>具体如何实现呢：</p><ol><li>确定栈帧布局，计算出buf到ret addr的offset。</li><li>先对buf填充无效数据，通过调试找出buf的首地址并覆盖ret addr。</li><li>用一段shellcode填充buf，这段shellcode会弹一个shell。</li></ol><hr><h4 id="4-you-jump-，i-jump-esp"><a href="#4-you-jump-，i-jump-esp" class="headerlink" title="4. you jump ，i jump esp"></a>4. you jump ，i jump esp</h4><p>以上的栈溢出是存在明显问题的。</p><p>首先就是硬编码buffer地址的缺陷：</p><pre><code>1. 对于不同版本系统来说，硬编码的地址是硬伤。Windows尚有dll装卸引起的“移位”。</code></pre><p>​    2. 在ASLR引入以后，栈每次运行基址都是随机的。</p><p><em>解决方法</em>：</p><p><strong>一般情况下，ESP寄存器中的地址总是指向系统栈中且不会被溢出的数据破坏，函数返回时，ESP所指向的位置恰好是我们所淹没的返回地址的下一个位置。</strong></p><p><img src="/2019/07/30/经典栈溢出问题/3.3.png" alt></p><p>现在问题就转化成了如何寻找“JMP ESP”的字节码地址。</p><p>本质：从内存空间的各个映像中寻觅”JMP ESP”的字节码地址。</p><ul><li><p>对Linux来说：<br>ELF映像本身<br>加载的so</p></li><li><p>对Windows来说：<br>PE映像本身<br>加载的dll</p></li></ul><p>要点：尽量择取具有高稳定性的”JMP ESP”指令的地址。</p><p>以上就是以我目前所学简单介绍一下栈溢出的问题，还有待补充，未完待续…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;经典栈溢出问题&quot;&gt;&lt;a href=&quot;#经典栈溢出问题&quot; class=&quot;headerlink&quot; title=&quot;经典栈溢出问题&quot;&gt;&lt;/a&gt;&lt;center&gt;经典栈溢出问题&lt;/center&gt;&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;​    说到二进制安全，肯定避不开栈溢出，今天就拿栈溢
      
    
    </summary>
    
    
      <category term="二进制" scheme="http://yoursite.com/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>漫漫二进制</title>
    <link href="http://yoursite.com/2019/07/30/%E6%BC%AB%E6%BC%AB%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    <id>http://yoursite.com/2019/07/30/漫漫二进制/</id>
    <published>2019-07-29T16:15:07.000Z</published>
    <updated>2019-07-29T16:26:46.165Z</updated>
    
    <content type="html"><![CDATA[<center><h4 id="我的二进制之路"><a href="#我的二进制之路" class="headerlink" title="我的二进制之路"></a><center>我的二进制之路</center></h4><p><em>当我狠下心想学习二进制安全的时候，可能我已经疯了。</em></p><p>​                                                                                        <em>——写在前面</em></p><hr><p>​    先聊聊其他的，关于二进制安全这一方面，我一开始也刷了很多别人的评论与看法，有从入门到放弃的，有行业顶尖大牛的，褒贬不一。但比较中肯的统一的看法是：入门难，就业难。</p><p>​    诶，人生不易。好不容易，遇到了自己感兴趣的东西，还是坚持一下吧，学习总会是有收获的。就算以后改行了，至少会因为自己为了小小的梦想而努力过高兴吧。</p><p>首先，二进制安全，初衷是什么？</p><p>答案是宏伟的：<strong>拥有getshell任意一台电脑的能力</strong></p><p>（据小道消息透露，“安全就是个失败的方向，而二进制又是失败中的失败”，有点苦涩哈哈哈哈）</p><p>​    好了好了，言归正传，那么如何系统的学习二进制安全呢?</p><p>​    其实我也不知道…</p><p>​    我看了很多别人的说法，还是有点分歧，但有一点是不会变得，那就是最底层的东西，C啊，C++啊，好吧，这些都能变，那汇编呢，机器语言呢，这总不会变了吧。</p><p>​    那就行开始吧。</p><p>​    路漫漫其修远兮，吾将上下而求索。</p><p>​    先贴一张图，<strong>提问的智慧</strong>，感觉还是蛮有意思的</p><p>   <img src="/2019/07/30/漫漫二进制/1.jpeg" alt></p><hr><p>​    这篇文章不聊技术向的问题，就聊个大概的学习路线。</p><ul><li><p>​    学习二进制，最起码的语言要会吧？</p><pre><code>1. x86汇编2. c / c++3. python4. windows编程（可以隶属c / c++）</code></pre><p>以上是我现在看了个一知半解的，以后肯定还要学习其他的，以后再说</p></li><li><p>​    要会二进制，没有一手拿得出手的敲代码能力怎么行？</p><pre><code>1. windows核心编程2. c/c++3. python4. python的灰帽子与自动化运维5. 精通黑客脚本</code></pre></li><li><p>​    学二进制，没有一点系统知识真的好吗？</p><pre><code>1. 深入理解计算机原理2. 深入理解linux内核3. windows内核安全编程4. windows内核的原理与实现5. 操作系统（这门课还挂了，难搞哦~）</code></pre></li><li><p>​    没有技巧，学什么二进制，还不如溜了溜了</p><pre><code>1. reversing C ++2. c++的反汇编与逆向分析3. 软件调试案例4. 黑客攻防技术宝典5. 0day安全6. 漏洞战争-软件漏洞分析技术7. 逆向工程核心原理8. 加密与解密9. IDA Pro权威指南</code></pre></li><li><p>​     学习是死的，总得动手去干吧</p><pre><code>1. 游戏外挂开放艺术2. 捉虫日记3. 黑客面杀4. 恶意代码分析5. 安全软件开发之道6. The Shellcodes Handbook</code></pre></li></ul><p>​    冰山一角。</p><p>​    先列下来这么多，以后有什么继续要学的再慢慢补充。</p><p>​    欢迎大家提出意见，一起交流学习。</p><p>​    关于技术向的干货，慢慢补充。</p><p>​    一边学习，一边思考，一边记录，</p><p>​    <strong>永远保持一颗好奇心</strong>，</p><p>   头发我不要了还不行吗。</p></center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;

&lt;h4 id=&quot;我的二进制之路&quot;&gt;&lt;a href=&quot;#我的二进制之路&quot; class=&quot;headerlink&quot; title=&quot;我的二进制之路&quot;&gt;&lt;/a&gt;&lt;center&gt;我的二进制之路&lt;/center&gt;&lt;/h4&gt;&lt;p&gt;&lt;em&gt;当我狠下心想学习二进制安全的时候，可能
      
    
    </summary>
    
    
      <category term="二进制" scheme="http://yoursite.com/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>windows编程之句柄hwnd与hdc的区别</title>
    <link href="http://yoursite.com/2019/07/28/windows%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%8F%A5%E6%9F%84hwnd%E4%B8%8Ehdc%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2019/07/28/windows编程之句柄hwnd与hdc的区别/</id>
    <published>2019-07-28T03:09:45.000Z</published>
    <updated>2019-07-29T00:48:26.255Z</updated>
    
    <content type="html"><![CDATA[<h3 id="谈谈hdc与hwnd的区别"><a href="#谈谈hdc与hwnd的区别" class="headerlink" title="谈谈hdc与hwnd的区别"></a><center>谈谈hdc与hwnd的区别</center></h3><hr><h4 id="hWnd-与hDC的概念"><a href="#hWnd-与hDC的概念" class="headerlink" title="hWnd 与hDC的概念"></a>hWnd 与hDC的概念</h4><p><strong>hWnd</strong>(Handle of Window，也可以这么说：h是类型描述，表示句柄；wnd是变量对象描述，表示窗口)是窗口句柄，其中包含窗口的属性。例如，窗口的大小、显示位置、父窗口。</p><p><strong>hDC</strong>(Handle to Device Context)是图像的设备描述表，窗口显示上下文句柄，其中可以进行图形显示。</p><p>利用hDC=GetDC(hWnd)，可以获得一个窗口的图形设备描述表。可以通过ReleaseDC()函数释放。</p><p>hWnd句柄是描述一个窗口的形状、位置、大小、是否显示、它的父窗口、兄弟窗口、等等的一组数据结构；<br>hDC句柄是一个实实在在的用于具体表现这个窗口时，需要对这个窗口有个场合来实现的地方。</p><p>hWnd是窗体句柄；hDC是设备场景句柄。<br>hWnd与窗口管理有关；hDC与绘图API（GDI函数）有关。<br>hWnd是windows给窗口发送消息（事件）用的；hDC是把窗口绘制在屏幕上用的。</p><p>有了hWnd，可以使用API的GetDC()函数得到与其相关的hDC：hDC=GetDC(hWnd)。</p><p>hWnd与hDC都是句柄，但是<strong>hWnd是窗口句柄而hDC是设备描述表的句柄</strong>。</p><p>在Windows标编程设计中，使用了大量的句柄来标识对象。一个句柄是指使用的一个唯一的整数值，即一个4字节（64位程序中为8字节）长的数值，来标识应用程序中的不同对象和同类中的不同的实例，例如：一个窗口、按钮、图标、滚动条、输出设备、孔健、文件等。应用程序能通过句柄来访问相应的对象的信息。但是<strong>句柄不是指针，程序不能利用句柄来直接阅读文件中的信息。如果句柄不在I/O文件中，它是毫无用处的。</strong>我们来看看另一个好理解的说法：在进程的地址空间中设一张表，表里头专门保存一些编号和由这个编号对应一个地址，而由那个地址去引用实际的对象，这个编号跟那个地址在数值上没有任何规律性的联系，纯粹是个映射而已。在Windows系统中，这个编号就叫做”句柄”。</p><p>句柄实际上是一种指向某种资源的指针，但与指针又有所不同：HWND是跨进程可见的，而指针从来都是属于某个特定进程的。指针对应着一个数据在内存中的地址，得到了指针就可以自由地修改该数据。Windows并不希望一般程序修改其内部数据结构，因为这样太不安全。所以Windows给每个使用GlobalAlloc等函数声明的内存区域指定一个句柄(本质上仍是一个指针，但不要直接操作它)，平时我们只是在调用API函数时利用这个句柄来说明要操作哪段内存。</p><hr><h4 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h4><p>​    HWND hwnd;//窗口句柄<br>​    char szAppName[] = “window1”;</p><p>//创建窗口<br>    hwnd = CreateWindow(szAppName, //窗口类型名<br>            TEXT(“The First Experiment”), //窗口实例的标题<br>            WS_OVERLAPPEDWINDOW, //窗口风格<br>            CW_USEDEFAULT, //窗口左上角位置坐标值x<br>            CW_USEDEFAULT, //窗口左上角位置坐标值y<br>            800, //窗口的宽度<br>            600, //窗口的高度<br>            NULL, //父窗口的句柄<br>            NULL, //主菜单的句柄<br>            hInstance, //应用程序实例句柄<br>            NULL );<br>　　　　//显示窗口<br>    ShowWindow(hwnd, iCmdShow);<br>    UpdateWindow(hwnd);</p><pre><code>static int nWidth, nHeight;HDC hdc;//定义设备环境句柄  HBRUSH hB;//定义画笔句刷</code></pre><p>case WM_LBUTTONDOWN://按下鼠标左键则用户区被刷成灰色<br>            nWidth = GetSystemMetrics(SM_CXFULLSCREEN);  //屏幕宽度<br>            nHeight = GetSystemMetrics(SM_CYFULLSCREEN); //屏幕高度<br>            hdc=GetDC(hwnd);<br>            hB = (HBRUSH)GetStockObject(GRAY_BRUSH);//灰色画刷<br>            SelectObject(hdc, hB);<br>            Rectangle(hdc, 0, 0, nWidth, nHeight);//将用户区重新刷成灰色<br>            DeleteObject(hB);//删除画刷</p><p>​            return 0;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;谈谈hdc与hwnd的区别&quot;&gt;&lt;a href=&quot;#谈谈hdc与hwnd的区别&quot; class=&quot;headerlink&quot; title=&quot;谈谈hdc与hwnd的区别&quot;&gt;&lt;/a&gt;&lt;center&gt;谈谈hdc与hwnd的区别&lt;/center&gt;&lt;/h3&gt;&lt;hr&gt;
&lt;h4 id=
      
    
    </summary>
    
    
      <category term="windows" scheme="http://yoursite.com/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>windows编程之句柄hwnd详解</title>
    <link href="http://yoursite.com/2019/07/28/windows%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%8F%A5%E6%9F%84hwnd%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/07/28/windows编程之句柄hwnd详解/</id>
    <published>2019-07-28T01:54:21.000Z</published>
    <updated>2019-07-29T16:21:57.993Z</updated>
    
    <content type="html"><![CDATA[<h3 id="深入了解Windows句柄是什么"><a href="#深入了解Windows句柄是什么" class="headerlink" title="深入了解Windows句柄是什么"></a><center>深入了解Windows句柄是什么</center></h3><hr><p>Windows是一个以虚拟内存为基础的操作系统，很多时候，进程的代码和数据并不全部装入内存，进程的某一段装入内存后，还可能被换出到外存，当再次需要时，再装入内存。两次装入的地址绝大多数情况下是不一样的。也就是说，同一对象在内存中的地址会变化。那么，程序怎么才能准确地访问到对象呢？为了解决这个问题，Windows引入了句柄。</p><hr><h4 id="1-虚拟内存结构"><a href="#1-虚拟内存结构" class="headerlink" title="1.虚拟内存结构"></a>1.虚拟内存结构</h4><p>CPU通过寻址来访问内存，32位CPU的寻址宽度度是 0~0xFFFFFFFF ，计算后得到的大小是4G，也就是说可支持的物理内存最大是4G。但在实践过程中，碰到了这样的问题，程序需要使用4G内存，而可用物理内存小于4G，导致程序不得不降低内存占用，这个时候操作系统就会借助磁盘空间来做虚拟的内存空间，把<strong>当前进程不需要的数据放在磁盘上，等到用到的时候，在利用调度算法把所需要的数据从磁盘空间上调度到内存</strong>，虚拟内存就是为了扩大内存的容量，每当我们要运行一个程序的时候经过编译以后形成的仅仅是逻辑上的空间，根本不是可以直接运行的内存空间，所以它还存在一个地址映射的概念。</p><p>为了解决这一问题，CPU引入<strong><em>MMU</em></strong>（内存管理单元）</p><p>MMU的核心思想是利用虚拟地址替代物理地址。CPU寻址时使用虚拟地址，MMU将虚拟地址映射为物理地址，他的引入解决了对物理内存的限制。</p><p>既然有了内存管理单元，就得有内存管理机制——内存分页（Paging）</p><p>它将虚拟地址和物理地址按照固定大小（4K）分割成页(page)和页帧(page frame)，并保证页与页帧的大小相同，所以页的个数必定多于页帧的个数。</p><p>在计算机上有一个页表（page table），就是映射虚拟内存页到物理内存页的，更确切的说是页号到页帧号的映射，而且是一对一的映射。但是问题来了，虚拟内存页的个数 &gt; 物理内存页帧的个数，岂不是有些虚拟内存页的地址永远没有对应的物理内存地址空间？不是的，操作系统是这样处理的。操作系统有个页面失效（page fault）功能。操作系统找到一个最少使用的页帧，让他失效，并把它写入磁盘，随后把需要访问的页放到页帧中，并修改页表中的映射，这样就保证所有的页都有被调度的可能了。</p><p><strong>虚拟内存地址由页号（对应映射到一个页帧）和偏移量组成</strong></p><p>偏移量：就是页（或者页帧）的大小，即这个页（或者页帧）到底能存多少数据。举个例子，有一个虚拟地址它的页号是4，偏移量是20，那么他的寻址过程是这样的：首先到页表中找到页号4对应的页帧号（比如为8），如果页不在内存中，则用失效机制调入页，否则把页帧号和偏移量传给MMU（CPU的内存管理单元）组成一个物理上真正存在的地址，接着就是访问物理内存中的数据了。总结起来说，虚拟内存地址的大小是与地址总线位数相关，物理内存地址的大小跟物理内存条的容量相关。</p><p><img src="/2019/07/28/windows编程之句柄hwnd详解/custom.jpg" alt></p><p>进一步优化，引入TLB（Translation lookaside buffer，页表寄存器缓冲）<br>由上一节可知，页表是被存储在内存中的。我们知道CPU通过总线访问内存，肯定慢于直接访问寄存器的。<br>为了进一步优化性能，现代CPU架构引入了<a href="http://baike.baidu.com/view/129737.html?fromTaglist" target="_blank" rel="noopener">TLB</a>，用来缓存一部分经常访问的页表内容。</p><hr><h4 id="2-什么是句柄"><a href="#2-什么是句柄" class="headerlink" title="2.什么是句柄"></a>2.什么是句柄</h4><p>系统为每个进程在内存中分配一定的区域，用来存放各个句柄，即一个个32位无符号整型值（32位操作系统中）。每个32位无符号整型值相当于一个指针，指向内存中的另一个区域（我们不妨称之为区域A）。而区域A中存放的正是对象在内存中的地址。当对象在内存中的位置发生变化时，区域A的值被更新，变为当前时刻对象在内存中的地址，而在这个过程中，区域A的位置以及对应句柄的值是不发生变化的。这种机制，用一种形象的说法可以表述为：有一个固定的地址（句柄），指向一个固定的位置（区域A），而区域A中的值可以动态地变化，它时刻记录着当前时刻对象在内存中的地址。这样，无论对象的位置在内存中如何变化，只要我们掌握了句柄的值，就可以找到区域A，进而找到该对象。而句柄的值在程序本次运行期间是绝对不变的，我们（即系统）当然可以掌握它。这就是以不变应万变，按图索骥，顺藤摸瓜。</p><p>那么这里我们就要修正一下前面的说法了：通用句柄HANDLE有时候是逻辑指针，大多数时候是结构体指针，特殊句柄如HMENU等是结构体指针。这样第二个问题也解决了。</p><p><img src="/2019/07/28/windows编程之句柄hwnd详解/20131230103702500.png" alt></p><hr><h4 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a><strong>3.总结</strong></h4><p> 所以，我们可以这样理解Windows句柄：</p><pre><code>数值上，是一个32位无符号整型值（32位系统下）；逻辑上，相当于指针的指针；形象理解上，是Windows中各个对象的一个唯一的、固定不变的ID；作用上，Windows使用句柄来标识诸如窗口、位图、画笔等对象，并通过句柄找到这些对象。</code></pre><p>下面，关于句柄，再交代一些关键性细节：</p><p>1.所谓“唯一”、“不变”是指在程序的<strong>一次运行</strong>中。如果本次运行完，关闭程序，再次启动程序运行，那么这次运行中，同一对象的句柄的值和上次运行时比较，一般是不一样的。</p><p>  其实这理解起来也很自然，所谓“一把归一把，这把是这把，那把是那把，两者不相干”（“把”是形象的说法，就像打牌一样，这里指程序的一次运行）。</p><p>2.句柄是对象生成时系统指定的，<strong>属性是只读的，程序员不能修改句柄</strong>。</p><p>3.不同的系统中，句柄的大小（字节数）是不同的，可以使用sizeof()来计算句柄的大小。</p><p>4.通过句柄，程序员只能调用系统提供的服务（即API调用），<strong>不能像使用指针那样，做其它的事。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;深入了解Windows句柄是什么&quot;&gt;&lt;a href=&quot;#深入了解Windows句柄是什么&quot; class=&quot;headerlink&quot; title=&quot;深入了解Windows句柄是什么&quot;&gt;&lt;/a&gt;&lt;center&gt;深入了解Windows句柄是什么&lt;/center&gt;&lt;/h3&gt;
      
    
    </summary>
    
    
      <category term="windows" scheme="http://yoursite.com/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>windows编程</title>
    <link href="http://yoursite.com/2019/07/28/windows%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/07/28/windows编程/</id>
    <published>2019-07-28T01:31:37.000Z</published>
    <updated>2019-07-29T03:26:27.981Z</updated>
    
    <content type="html"><![CDATA[<h3 id="windows编程随笔"><a href="#windows编程随笔" class="headerlink" title="windows编程随笔"></a><center>windows编程随笔</center></h3><hr><h4 id="1-从MessageBox开始"><a href="#1-从MessageBox开始" class="headerlink" title="1.从MessageBox开始"></a>1.从MessageBox开始</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MessageBox</span><span class="params">( </span></span></span><br><span class="line"><span class="function"><span class="params">    HWND hWnd,</span></span></span><br><span class="line"><span class="function"><span class="params">    LPCTSTR lpText, </span></span></span><br><span class="line"><span class="function"><span class="params">    LPCTSTR lpCaption,</span></span></span><br><span class="line"><span class="function"><span class="params">    UINT wType </span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>;</span><br></pre></td></tr></table></figure><p>观察具体几个参数：</p><p><strong>hWnd</strong>：</p><p>为父窗口<u>句柄</u>，指定该对话框的所有者窗口。如果该参数为空(0/NULL)，则该对话框不属于任何窗口。</p><p><strong>lpText</strong>:</p><p>显示在对话框中的消息。</p><p><strong>lpCaption</strong>：</p><p>在对话框<a href="https://baike.baidu.com/item/标题栏" target="_blank" rel="noopener">标题栏</a>中显示的字符串<a href="https://baike.baidu.com/item/表达式" target="_blank" rel="noopener">表达式</a>。如果该参数为空（vbNullString），则使用默认的“错误”作为对话框的标题。</p><p><strong>wType</strong>：</p><p>指定显示按钮的数目及形式</p><hr><ul><li><h4 id="那么问题出现了，句柄代表的到底是什么"><a href="#那么问题出现了，句柄代表的到底是什么" class="headerlink" title="那么问题出现了，句柄代表的到底是什么"></a>那么问题出现了，句柄代表的到底是什么</h4></li></ul><p><em>简单的来说，句柄就是类似指针的标识</em></p><p>1.windows 之所以要设立句柄，根本上源于<a href="http://baike.baidu.com/view/1082.htm" target="_blank" rel="noopener">内存</a>管理机制的问题—<a href="http://baike.baidu.com/view/1499823.htm" target="_blank" rel="noopener">虚拟地址</a>，简而言之数据的地址需要变动，变动以后就需要有人来记录管理变动，（就好像户籍管理一样），因此系统用句柄来记载数据地址的变更。</p><p>2.更透彻一点地认识句柄，句柄是一种指向<a href="http://baike.baidu.com/view/159417.htm" target="_blank" rel="noopener">指针</a>的<a href="http://baike.baidu.com/view/159417.htm" target="_blank" rel="noopener">指针</a>但是它的属性是只读的。</p><hr><ul><li><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4></li></ul><p>那么一个完整的MessageBox便展现出来了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE hinstance, HINSTANCE hprevinstance, PSTR szCmdLine, <span class="keyword">int</span> iCmdShow)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MessageBox(<span class="literal">NULL</span>, </span><br><span class="line">        TEXT(<span class="string">"this is content !"</span>),</span><br><span class="line">               TEXT(<span class="string">"this is title !"</span>),</span><br><span class="line">               MB_OK);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*WinMain()函数的原型声明</span></span><br><span class="line"><span class="comment">int WINAPI WinMain(</span></span><br><span class="line"><span class="comment">  HINSTANCE hInstance,//当前运行实例句柄</span></span><br><span class="line"><span class="comment">  HINSTANCE hPrevInstance,//前一个实例句柄</span></span><br><span class="line"><span class="comment">  LPSTR lpCmdLine,//指定命令参数行字符串</span></span><br><span class="line"><span class="comment">  int nCmdShow;//指定窗口的显示状态</span></span><br><span class="line"><span class="comment">)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">MessageBox函数声明</span></span><br><span class="line"><span class="comment">int MessageBox(</span></span><br><span class="line"><span class="comment">   HWND hWnd,//所属窗口的句柄</span></span><br><span class="line"><span class="comment">   LPCTSTR lpText,//消息字符串</span></span><br><span class="line"><span class="comment">   LPCTSTR lpCaption,//消息框标题字符串</span></span><br><span class="line"><span class="comment">   UNIT uType//消息框的类型</span></span><br><span class="line"><span class="comment">);*/</span></span><br></pre></td></tr></table></figure><hr><ul><li><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4></li></ul><p>在<code>MB_OK</code>处转到定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MB_OK                       0x00000000L</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MB_OKCANCEL                 0x00000001L</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MB_ABORTRETRYIGNORE         0x00000002L</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MB_YESNOCANCEL              0x00000003L</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MB_YESNO                    0x00000004L</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MB_RETRYCANCEL              0x00000005L</span></span><br></pre></td></tr></table></figure><p>对应关系 ：MB_OK 对应十六进制的0？</p><p>用 1 来替换 MB_OK 一样可以得到结果吗？</p><p>bingo！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MessageBox(<span class="literal">NULL</span>, </span><br><span class="line">        TEXT(<span class="string">"this is content !"</span>),</span><br><span class="line">               TEXT(<span class="string">"this is title !"</span>),</span><br><span class="line">               <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>编译通过！</p><hr><h4 id="2-匈牙利命名法"><a href="#2-匈牙利命名法" class="headerlink" title="2.匈牙利命名法"></a>2.匈牙利命名法</h4><p>对于上面MessageBox函数中奇奇怪怪的参数，它们使用了匈牙利命名法。</p><p>  这种标记法非常简单，即变量名以一个或者多个小写字母开始，这些字母表示变量的数据型态。例如：szCmdLine 中的 sz 代表“以0结尾的字符串（StringZero）”；在 hInstance 和 hPrevInstance 中的 h 前缀表示“句柄（Handle）”；在 iCmdShow 中的 i 前缀表示“整型（Integer）”。</p><p>当命名结构变量时，可以用结构名（或者结构名的一种缩写）的小写形式作为变量名称的前缀，或者用作整个变量名。例如：msg 变量是 MSG 型态的结构；wndclass 是 WNDCLASSEX 型态的一个结构；ps 是一个 PAINTSTRUCT 结构，rect 是一个 RECT 结构。</p><p>匈牙利表示法能够帮助程序写作者及早发现并避免程序中的错误。由于变量名既描述了变量的作用，又描述了其数据型态，就比较容易避免产生数据型态不合的错误。</p><table><thead><tr><th><strong>前缀</strong></th><th><strong>数据类型</strong></th></tr></thead><tbody><tr><td>i</td><td>int（整型）</td></tr><tr><td>c</td><td>char 或 WCHAR 或 TCHAR</td></tr><tr><td>by</td><td>BYTE （无符号字符）</td></tr><tr><td>x, y</td><td>int，表示 x 坐标和 y 坐标</td></tr><tr><td>l</td><td>LONG（长整型）</td></tr><tr><td>B 或 f</td><td>BOOL（int）；f 表示“flag”</td></tr><tr><td>w</td><td>WORD（无符号短整型）</td></tr><tr><td>dw</td><td>DWORD（无符号长整型）</td></tr><tr><td>fn</td><td>函数</td></tr><tr><td>s</td><td>字符串</td></tr><tr><td>sz</td><td>以零结束的字符串</td></tr><tr><td>h</td><td>句柄</td></tr><tr><td>p</td><td>指针</td></tr><tr><td>cx, cy</td><td>int，表示 x 或 y 的长度，c 表示“count”（计数）</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;windows编程随笔&quot;&gt;&lt;a href=&quot;#windows编程随笔&quot; class=&quot;headerlink&quot; title=&quot;windows编程随笔&quot;&gt;&lt;/a&gt;&lt;center&gt;windows编程随笔&lt;/center&gt;&lt;/h3&gt;&lt;hr&gt;
&lt;h4 id=&quot;1-从Mess
      
    
    </summary>
    
    
      <category term="windows" scheme="http://yoursite.com/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>my first blog</title>
    <link href="http://yoursite.com/2019/07/28/my-first-blog/"/>
    <id>http://yoursite.com/2019/07/28/my-first-blog/</id>
    <published>2019-07-27T17:15:07.000Z</published>
    <updated>2019-07-29T00:38:58.224Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第一个博客"><a href="#第一个博客" class="headerlink" title="第一个博客"></a><center>第一个博客</center></h3><hr><p>第一个博客，简单记录一下markdown的快捷键吧</p><hr><h4 id="Typora快捷键"><a href="#Typora快捷键" class="headerlink" title="Typora快捷键"></a>Typora快捷键</h4><ul><li><h5 id="选中"><a href="#选中" class="headerlink" title="选中"></a>选中</h5></li></ul><p>选中一整行：ctrl+l<br>选中单词：ctrl+d<br>选中相同格式的文字：ctrl+e</p><ul><li><h5 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h5></li></ul><p>跳转到文章开头：ctrl+home<br>跳转到文章结尾：ctrl+end</p><ul><li><h5 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h5></li></ul><p>搜索：ctrl+f<br>替换：ctrl+h</p><ul><li><h5 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h5></li></ul><p>引用：输入&gt;之后输入空格<br>代码块：ctrl+alt+f；```+语言<br>标题：ctrl+数字<br>表格：ctrl+t<br>生成目录：[TOC]按回车<br>插入标注：输入[]，后面+任何<br>插入图片：直接拖动到指定位置即可或者ctrl+shift+i<br>插入链接：ctrl+k<br>插入表情：输入’:’之后输入英文单词<br>无序列表：输入-之后输入空格<br>有序列表：输入数字+“.”之后输入空格<br>todolist：-[空格]空格 文字</p><ul><li><h5 id="显示格式"><a href="#显示格式" class="headerlink" title="显示格式"></a>显示格式</h5></li></ul><p>加粗：ctrl+b<br>高亮：== 文字 ==<br>着重：ctrl+shift+反引号键（tab键上面那个键）<br>倾斜：ctrl+i<br>下划线：ctrl+u</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;第一个博客&quot;&gt;&lt;a href=&quot;#第一个博客&quot; class=&quot;headerlink&quot; title=&quot;第一个博客&quot;&gt;&lt;/a&gt;&lt;center&gt;第一个博客&lt;/center&gt;&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;第一个博客，简单记录一下markdown的快捷键吧&lt;/p&gt;
&lt;hr&gt;
&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2019/07/28/hello-world/"/>
    <id>http://yoursite.com/2019/07/28/hello-world/</id>
    <published>2019-07-27T16:29:39.537Z</published>
    <updated>2019-07-27T16:29:39.537Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
